<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ditado — Opções (Timer / Erradas / Narrador)</title>

  <!-- Favicon (SVG embutido, visual mais marcante) -->
  <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect width='100' height='100' rx='18' fill='%2310b981'/%3E%3Cg transform='translate(18,24)' fill='%23ffffff'%3E%3Crect x='6' y='6' width='50' height='36' rx='3'/%3E%3Cpath d='M6 6h50v6H6z' fill='%23e6f9ef'/%3E%3Ccircle cx='44' cy='20' r='6'/%3E%3C/g%3E%3C/svg%3E">

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">

  <style>
    :root{ --muted:#6c757d; --accent:#10b981; --err:#dc2626; --glass: rgba(255,255,255,0.75); }
    body { background: linear-gradient(180deg,#f3f6fb,#ffffff); font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 18px; }
    .card { border-radius: 14px; box-shadow: 0 8px 30px rgba(17,24,39,0.06); }
    .btn { transition: transform .12s ease, box-shadow .12s ease; border-radius: 10px; -webkit-tap-highlight-color: rgba(0,0,0,0); }
    .btn:hover { transform: translateY(-3px); } .btn:active { transform: translateY(-1px) scale(.995); }
    .btn.touch-large { min-height:48px; padding-top:.6rem; padding-bottom:.6rem; }
    .btn-config.pulse { animation: pulse 1.6s infinite; box-shadow: 0 8px 32px rgba(16,185,129,0.12); }
    @keyframes pulse { 0%{transform:translateY(0)}50%{transform:translateY(-3px)}100%{transform:translateY(0)} }
    .btn-rotate { animation: rotatePulse 0.72s ease; } @keyframes rotatePulse { 0%{transform:rotate(0deg) scale(1)}40%{transform:rotate(200deg) scale(1.06)}100%{transform:rotate(360deg) scale(1)} }

    /* Current word */
    #currentWordWrap { display:flex; flex-direction:column; align-items:center; gap:.5rem; }
    #currentWord{ font-weight:700; font-size:2.2rem; color:#0b2545; min-height:2.8rem; display:flex; align-items:center; justify-content:center; padding: .45rem 1rem; border-radius:12px; background: var(--glass); backdrop-filter: blur(4px); -webkit-backdrop-filter: blur(4px); box-shadow: 0 6px 18px rgba(11,37,69,0.04); transition: filter 220ms ease, opacity 220ms ease; max-width: 90%; word-break: break-word; text-align:center; }
    /* blurred state */
    .blurred { filter: blur(6px) grayscale(.15); }

    #timerDisplay{ color:var(--muted); font-weight:600; }
    .chip{ border-radius:999px; padding:.35rem .75rem; margin:.25rem; display:inline-flex; align-items:center; gap:.5rem; background:#fff3f2; color:#7a0f0f; cursor:pointer; transition: transform .12s ease; }
    .chip:hover{ transform: translateY(-4px); background:#ffdede; }
    .countdown-wrap{ display:flex; align-items:center; gap:1rem; justify-content:center; margin-top:10px; position:relative; }
    .ring{ width:72px; height:72px; position:relative; } .ring svg{ transform: rotate(-90deg); width:100%; height:100%; display:block; }
    .ring .center-label{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-weight:700; color:#0b2545; font-size:0.95rem; }

    .inactive-clock { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:28px; color:#6c757d; pointer-events:none; transition: transform .45s cubic-bezier(.2,.9,.3,1), opacity .35s ease; }
    .inactive-clock.hidden { opacity:0; transform: scale(.92) rotate(-10deg); pointer-events:none; }
    .inactive-clock.visible { opacity:1; transform: scale(1) rotate(0deg); }

    .anim-to-ring { animation: clockToRing .52s ease forwards; }
    @keyframes clockToRing {
      0% { transform: scale(1) rotate(0deg); opacity:1; }
      40% { transform: scale(1.18) rotate(12deg); opacity:0.85; }
      100% { transform: scale(.9) rotate(40deg); opacity:0; }
    }

    .progress-transition { transition: stroke 420ms linear, stroke-dashoffset 240ms linear; }

    /* espaçamentos */
    .controls-top { margin-bottom: 18px; display:flex; align-items:center; gap:12px; }
    .controls-bottom { margin-bottom: 18px; }
    #mainProxiesArea { margin: 18px 0; }

    @media (max-width:768px){
      .controls-top .col-auto{ width:100%; } .controls-top .btn{ width:100%; }
      .controls-bottom .col-auto{ width:100%; } .controls-bottom .btn{ width:100%; }
      .countdown-wrap{ flex-direction:column; gap:.5rem; } .ring{ width:86px; height:86px; } #currentWord{ font-size:1.6rem; }
      .keyboard-hint{ display:none !important; }
      .inactive-clock { font-size: 30px; } /* keep proportion on mobile */
    }
    @media (max-width:576px){ .ring{ width:64px; height:64px; } #currentWord{ font-size:1.4rem; } .inactive-clock { font-size:26px; } }
    .spaced-section{ margin-top:18px; margin-bottom:18px; }

    .proxy-btn { min-width: 120px; }
    .main-proxies { margin-bottom: 14px; display:flex; gap:.5rem; flex-wrap:wrap; justify-content:center; }
    .hidden { display:none !important; }

    /* help button — 30% menor (~26px) */
    .help-btn {
      width:26px; height:26px; border-radius:50%; padding:0; display:inline-flex; align-items:center; justify-content:center;
      background: linear-gradient(180deg,#0d6efd,#0069d9); color:white; border: none;
      box-shadow: 0 6px 16px rgba(13,110,253,0.18); font-weight:600; font-size:13px;
      transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease;
    }
    .help-btn:hover { transform: translateY(-3px) scale(1.03); box-shadow: 0 10px 22px rgba(13,110,253,0.22); opacity: .98; }
    .help-btn:active { transform: translateY(-1px) scale(.99); }

    .offcanvas .mb-3 h6 { margin-bottom: 6px; }

    /* pequeno espaçamento para o bloco de erradas sob o timer */
    #errorProxiesUnderTimer { margin-top: 12px; display:flex; gap:.5rem; justify-content:center; flex-wrap:wrap; }

    /* animação para aparição do botão Refazer Erradas */
    @keyframes popInRedo {
      0%   { transform: translateY(-8px) scale(.95); opacity: 0; }
      60%  { transform: translateY(4px)  scale(1.03); opacity: 1; }
      100% { transform: translateY(0)    scale(1);    opacity: 1; }
    }
    .redo-appear {
      animation: popInRedo 420ms cubic-bezier(.2,.9,.3,1);
    }

    /* total display style (fixo próximo aos controles) */
    #totalCountDisplay { min-width:180px; text-align:right; color:var(--muted); font-weight:600; }

    /* stylized counter (big pill) and eye button */
    .current-controls { display:flex; gap:.5rem; align-items:center; justify-content:center; }
    #wordCounter {
      background: linear-gradient(180deg, #ffffff, #f7fbff);
      border: 1px solid #e6eef8;
      padding: .4rem .7rem;
      border-radius: 999px;
      box-shadow: 0 6px 18px rgba(11,37,69,0.04);
      font-weight:700;
      font-size:0.95rem;
      color:#0b2545;
      min-width:80px;
      text-align:center;
    }
    #blurToggleBtn { min-width:40px; height:36px; display:inline-flex; align-items:center; justify-content:center; border-radius:8px; }

    /* === styles for copy icon feedback === */
    /* initial icon color is muted; but on hover we DO NOT change color, only scale */
    #copyErrorListBtn i {
      transition: color 220ms ease, transform 160ms ease;
      color: var(--muted);
      display:inline-block;
      line-height:1;
    }
    #copyErrorListBtn:hover i {
      transform: scale(1.08);
      color: #ffffff; /* hover color changed to white as requested earlier */
    }
    .copy-success {
      transform: scale(1.06);
      transition: color 260ms ease, transform 160ms ease;
      color: var(--accent) !important;
    }

    /* Reset button specific styling: slightly spaced and visually distinct */
    #resetBtn {
      margin-left: 12px; /* afastado um pouco dos outros */
      background: linear-gradient(180deg,#ffffff,#f8fafc);
      border: 1px solid #e2e8f0;
      box-shadow: 0 6px 18px rgba(2,6,23,0.04);
      border-radius: 12px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card p-3 mx-auto" style="max-width:980px;">
      <div class="d-flex align-items-center justify-content-between mb-2">
        <h3 class="mb-0">Ditado de Palavras</h3>
        <div>
          <button id="configBtn" class="btn btn-outline-secondary btn-config pulse" data-bs-toggle="offcanvas" data-bs-target="#configOffcanvas" aria-controls="configOffcanvas" title="Opções">
            <i class="bi bi-gear-fill"></i> Opções
          </button>
        </div>
      </div>

      <!-- TOP: Carregar / Iniciar / Randomizar / Reset + total fixo -->
      <div class="row g-2 mb-2 controls-top align-items-center">
        <div class="col-auto">
          <button id="loadBtn" class="btn btn-primary btn-lg touch-large">
            <i class="bi bi-download me-2"></i>Carregar
          </button>
        </div>

        <div class="col-auto">
          <button id="startBtn" class="btn btn-success btn-lg touch-large" disabled>
            <i class="bi bi-play-fill me-2"></i>Iniciar
          </button>
        </div>

        <div class="col-auto">
          <button id="shuffleBtn" class="btn btn-outline-secondary btn-lg touch-large" disabled>
            <i class="bi bi-shuffle me-2"></i>Randomizar
          </button>
        </div>

        <div class="col-auto">
          <button id="resetBtn" class="btn btn-outline-dark btn-lg touch-large" title="Resetar aplicação">
            <i class="bi bi-arrow-counterclockwise me-2"></i>Resetar
          </button>
        </div>

        <!-- total fixo de palavras carregadas -->
        <div class="col text-end">
          <div id="totalCountDisplay" class="small text-muted">Carregadas: 0</div>
        </div>
      </div>

      <textarea id="wordList" class="form-control mb-3" rows="6" placeholder="Insira uma palavra por linha..."></textarea>

      <!-- BOTTOM: Voltar / Próxima / Repetir -->
      <div class="row g-2 mb-3 controls-bottom justify-content-center">
        <div class="col-auto">
          <button id="prevBtn" class="btn btn-outline-dark btn-lg touch-large" disabled>
            <i class="bi bi-skip-start-fill me-1"></i> Voltar
          </button>
        </div>

        <div class="col-auto">
          <button id="nextBtn" class="btn btn-outline-dark btn-lg touch-large" disabled>
            Próxima <i class="bi bi-skip-end-fill ms-1"></i>
          </button>
        </div>

        <div class="col-auto">
          <button id="repeatBtn" class="btn btn-outline-primary btn-lg btn-repeat touch-large" title="Repetir palavra (Seta ↑)">
            <i class="bi bi-arrow-repeat"></i> Repetir
          </button>
        </div>
      </div>

      <!-- Timer proxies (continuam aqui) -->
      <div id="mainProxiesArea" class="text-center mb-3">
        <div id="mainTimerProxies" class="main-proxies hidden" aria-hidden="true">
          <input id="intervalInputProxy" type="number" min="1" value="3" class="form-control" style="width:120px;">
          <button id="startTimerProxy" class="btn btn-success proxy-btn hidden">Iniciar Timer</button>
          <button id="pauseProxy" class="btn btn-warning proxy-btn hidden" title="Pausar (proxy)"><i class="bi bi-pause-fill me-1"></i> Pausar</button>
        </div>
      </div>

      <!-- Área central: palavra e contador (com ícone inativo) -->
      <div class="text-center mb-2 spaced-section">
        <div id="currentWordWrap">
          <!-- controls: blur eye + styled counter -->
          <div class="current-controls">
            <button id="blurToggleBtn" class="btn btn-sm btn-outline-secondary" title="Alternar palavra borrada/visível" aria-pressed="false">
              <i id="blurIcon" class="bi bi-eye"></i>
            </button>
            <div id="wordCounter" aria-live="polite">0 / 0</div>
          </div>

          <div id="currentWord" aria-live="polite" aria-atomic="true"></div>
        </div>

        <div class="countdown-wrap" aria-hidden="false">
          <div class="ring" aria-hidden="true">
            <!-- SVG ring (progresso) -->
            <svg id="countdownSvg" viewBox="0 0 100 100" role="img" aria-label="Contador" style="display:block;">
              <circle cx="50" cy="50" r="44" stroke="#e6e6e6" stroke-width="10" fill="none"></circle>
              <circle id="progressCircle" cx="50" cy="50" r="44" stroke="#10b981" stroke-width="10" stroke-linecap="round" fill="none" stroke-dasharray="276.46" stroke-dashoffset="0" class="progress-transition"></circle>
            </svg>
            <!-- centro com segundos -->
            <div class="center-label" id="centerSeconds">-</div>
            <!-- ícone de relógio inativo (mostrado quando timer desativado) -->
            <div id="inactiveClock" class="inactive-clock visible" aria-hidden="true"><i class="bi bi-alarm"></i></div>
          </div>

          <div>
            <div id="timerDisplay" class="small"></div>
            <div id="status" class="text-muted small mt-1">Timer Desativado</div>
          </div>
        </div>

        <!-- bloco de botões de Ditado de Erradas (abaixo do timer) -->
        <div id="errorProxiesUnderTimer" class="mt-2">
          <div id="mainErrorProxies" class="main-proxies hidden" aria-hidden="true">
            <button id="addWrongProxy" class="btn btn-outline-danger proxy-btn">Adicionar Errada</button>
            <button id="startErrorProxy" class="btn btn-danger proxy-btn">Ditado Erradas</button>
            <button id="redoWrongProxy" class="btn btn-secondary proxy-btn hidden">Refazer Erradas</button>
            <button id="launchErrorProxy" class="btn btn-success proxy-btn hidden">Iniciar Erradas</button>
            <button id="clearErrorProxy" class="btn btn-outline-danger proxy-btn">Limpar Erradas</button>
          </div>
        </div>
      </div>

      <div id="wrongSection" class="mt-3" style="display:none;">
        <h6 class="mb-2 text-danger">Palavras Erradas (clique para remover)</h6>
        <div id="wrongWordsList"></div>
      </div>

      <div id="errorListSection" class="mt-3" style="display:none;">
        <h6 class="mb-2 text-secondary">
          Revisão (lista original de erradas)
          <button id="copyErrorListBtn" class="btn btn-sm btn-outline-secondary ms-2" title="Copiar lista de erradas"><i class="bi bi-clipboard"></i></button>
        </h6>
        <textarea id="errorListArea" class="form-control" rows="4" readonly></textarea>
      </div>

      <div class="mt-3 text-muted small keyboard-hint">
        Dica: use ← e → para navegar; pressione <span class="fw-bold">↓</span> para marcar a palavra atual como errada (quando o registro estiver ativo). Pressione <span class="fw-bold">↑</span> para repetir a palavra.
      </div>
    </div>
  </div>

  <!-- Offcanvas / painel de OPÇÕES -->
  <div class="offcanvas offcanvas-end" tabindex="-1" id="configOffcanvas" aria-labelledby="configOffcanvasLabel">
    <div class="offcanvas-header">
      <h5 class="offcanvas-title" id="configOffcanvasLabel"><i class="bi bi-gear-fill me-2"></i>Opções</h5>
      <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Fechar"></button>
    </div>

    <div class="offcanvas-body">
      <!-- Timer (com ícone) -->
      <div class="mb-3 d-flex align-items-start justify-content-between">
        <div>
          <h6 class="mb-1"><i class="bi bi-clock-history me-2"></i>Timer</h6>
        </div>
        <button class="help-btn" data-bs-toggle="modal" data-bs-target="#helpTimerModal" title="Ajuda Timer">?</button>
      </div>
      <div class="d-flex align-items-center gap-2 mb-3">
        <button id="autoBtn" class="btn btn-outline-success btn-sm">Automático</button>
      </div>

      <hr>

      <!-- Ditado de Erradas (com ícone removido no botão) -->
      <div class="mb-3 d-flex align-items-start justify-content-between">
        <div>
          <h6 class="mb-1"><i class="bi bi-exclamation-triangle me-2"></i>Ditado de Erradas</h6>
        </div>
        <button class="help-btn" data-bs-toggle="modal" data-bs-target="#helpErradasModal" title="Ajuda Erradas">?</button>
      </div>
      <div class="d-flex gap-2 mb-3">
        <button id="toggleErrorBtn" class="btn btn-outline-danger btn-sm">Registrar Erradas (↓)</button>
      </div>

      <hr>

      <!-- Narrador -->
      <div class="mb-3 d-flex align-items-start justify-content-between">
        <div>
          <h6 class="mb-1"><i class="bi bi-volume-up me-2"></i>Narrador</h6>
        </div>
        <button class="help-btn" data-bs-toggle="modal" data-bs-target="#helpNarradorModal" title="Ajuda Narrador">?</button>
      </div>

      <div class="d-flex flex-column gap-2 mb-2">
        <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" id="narratorToggle" checked>
          <label class="form-check-label" for="narratorToggle">Narrador (ativado)</label>
        </div>

        <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" id="announceNextToggle" checked>
          <label class="form-check-label" for="announceNextToggle">Falar "Próxima palavra" (ativado)</label>
        </div>

        <button id="unlockAudioBtn" class="btn btn-info btn-sm d-none" title="Destravar áudio"><i class="bi bi-volume-up me-1"></i> Tocar áudio (ativar voz)</button>
      </div>
    </div>
  </div>

  <!-- HELP MODALS (mantidos) -->
  <div class="modal fade" id="helpTimerModal" tabindex="-1" aria-labelledby="helpTimerModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="helpTimerModalLabel"><i class="bi bi-clock-history me-2"></i>Sobre o Timer</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
        </div>
        <div class="modal-body">
          <p>Ao ativar <strong>Automático</strong> aqui, os controles do timer aparecem na tela principal (intervalo e botão “Iniciar Timer”).</p>
          <ul>
            <li>É necessário primeiro iniciar o ditado com <strong>Iniciar</strong> (botão acima da lista). Depois, clique em <strong>Iniciar Timer</strong> para disparar o cronômetro automático.</li>
            <li>Se nenhuma palavra estiver carregada, o sistema solicitará que você carregue palavras antes do início.</li>
            <li>Use <em>Pausar</em> para interromper a contagem e <em>Retomar</em> para continuar (aparecerá apenas quando o timer tiver sido iniciado).</li>
          </ul>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="helpErradasModal" tabindex="-1" aria-labelledby="helpErradasModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="helpErradasModalLabel"><i class="bi bi-exclamation-triangle me-2"></i>Sobre Ditado de Erradas</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
        </div>
        <div class="modal-body">
          <p>Quando <strong>Registrar Erradas</strong> está ativado, você pode marcar palavras que errar e revisá-las depois.</p>
          <ul>
            <li>Use a tecla <strong>↓ (seta para baixo)</strong> para marcar a palavra atual como errada quando o registro estiver ativo.</li>
            <li>Ao finalizar a revisão de erradas, aparecerá o botão <strong>Refazer Erradas</strong> — ele remove as gerações filhas da geração revisada (ou seja, exclui as palavras geradas a partir dela) e permite refazer a revisão dessa geração.</li>
            <li>O botão <strong>Ditado Erradas</strong> prepara e inicia a revisão da última lista de erradas disponível.</li>
          </ul>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="helpNarradorModal" tabindex="-1" aria-labelledby="helpNarradorModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="helpNarradorModalLabel"><i class="bi bi-volume-up me-2"></i>Sobre o Narrador</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
        </div>
        <div class="modal-body">
          <p>As opções do narrador permitem controlar a leitura das palavras e anúncios:</p>
          <ul>
            <li><strong>Narrador</strong>: ativa/desativa a leitura das palavras; também controla o botão Repetir.</li>
            <li><strong>Falar "Próxima palavra"</strong>: controla apenas a frase anunciada antes do avanço; se ativado, o anúncio será executado mesmo que o Narrador esteja desativado.</li>
          </ul>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" defer></script>

  <!-- SCRIPT principal (único arquivo) -->
  <script defer>
    const STORAGE_KEY = 'ditadoState_v1';

    // === Elementos principais ===
    const loadBtn = document.getElementById('loadBtn');
    const startBtn = document.getElementById('startBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const resetBtn = document.getElementById('resetBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const repeatBtn = document.getElementById('repeatBtn');

    const autoBtn = document.getElementById('autoBtn');
    const toggleErrorBtn = document.getElementById('toggleErrorBtn');

    // proxies timer
    const startTimerProxy = document.getElementById('startTimerProxy');
    const pauseProxy = document.getElementById('pauseProxy');
    const intervalInputProxy = document.getElementById('intervalInputProxy');

    // proxies erradas (agora abaixo do timer)
    const addWrongProxy = document.getElementById('addWrongProxy');
    const startErrorProxy = document.getElementById('startErrorProxy');
    const redoWrongProxy = document.getElementById('redoWrongProxy');
    const launchErrorProxy = document.getElementById('launchErrorProxy');
    const clearErrorProxy = document.getElementById('clearErrorProxy');

    const inactiveClock = document.getElementById('inactiveClock');
    const progressCircle = document.getElementById('progressCircle');
    const centerSeconds = document.getElementById('centerSeconds');

    const narratorToggle = document.getElementById('narratorToggle');
    const announceNextToggle = document.getElementById('announceNextToggle');

    const wordListEl = document.getElementById('wordList');
    const currentWordEl = document.getElementById('currentWord');
    const timerDisplay = document.getElementById('timerDisplay');
    const statusEl = document.getElementById('status');
    const wrongSection = document.getElementById('wrongSection');
    const wrongWordsList = document.getElementById('wrongWordsList');
    const errorListSection = document.getElementById('errorListSection');
    const errorListArea = document.getElementById('errorListArea');
    const totalCountDisplay = document.getElementById('totalCountDisplay');

    const blurToggleBtn = document.getElementById('blurToggleBtn');
    const blurIcon = document.getElementById('blurIcon');
    const wordCounterEl = document.getElementById('wordCounter');

    // copy button for error list
    const copyErrorListBtn = document.getElementById('copyErrorListBtn');

    // Estado básico
    let words = [];
    let index = 0;
    let errorMode = false;

    // Gestão de erradas com gerações
    let wrongGenerations = [];                // array de arrays (G0, G1, ...)
    let currentMarkedWrongWords = [];        // marcas feitas fora de revisão (mostradas em Palavras Erradas)
    let reviewMarkedWrongWords = [];         // marcas durante revisão (serão geração filha)
    let currentGenerationIndex = -1;         // geração em revisão (pai) -> index em wrongGenerations
    let lastReviewedGenerationIndex = -1;    // última geração finalizada
    let isReviewMode = false;
    let canShowRedo = false;

    let lastLoadedMain = 0;
    let lastLoadedWrong = 0;

    // timing/timer
    let ringRaf = null;
    let ringStartTime = null;
    let ringDuration = null;
    let endTimer = null;
    let tickInterval = null;

    let remainingSec = 0;
    let isAuto = false;
    let isPaused = false;
    let awaitingAnnouncement = false;
    let pendingLaunch = false;
    let autoArmed = false;

    let dictationRunning = false;

    // narrator flags
    let narratorEnabled = !!(narratorToggle && narratorToggle.checked);
    let announceNextEnabled = !!(announceNextToggle && announceNextToggle.checked);

    let audioUnlocked = false;

    // blur state
    let blurOn = false;

    const R = 44;
    const CIRC = 2 * Math.PI * R;
    if (progressCircle) {
      progressCircle.style.strokeDasharray = `${CIRC}`;
      progressCircle.style.strokeDashoffset = `${CIRC}`;
    }

    const startColor = { r: 16, g: 185, b: 129 };
    const endColor = { r: 220, g: 38, b: 38 };

    function lerp(a,b,t){ return Math.round(a + (b-a)*t); }
    function colorLerp(c1,c2,t){ return `rgb(${lerp(c1.r,c2.r,t)}, ${lerp(c1.g,c2.g,t)}, ${lerp(c1.b,c2.b,t)})`; }

    /* ========== Persistência (localStorage) ========== */
    function saveState(){
      try {
        const state = {
          wordListRaw: wordListEl ? wordListEl.value : '',
          words,
          index,
          errorMode,
          wrongGenerations,
          currentMarkedWrongWords,
          reviewMarkedWrongWords,
          currentGenerationIndex,
          lastReviewedGenerationIndex,
          isReviewMode,
          pendingLaunch,
          lastLoadedMain,
          lastLoadedWrong,
          narratorEnabled,
          announceNextEnabled,
          blurOn,
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch(e){ console.warn('Não foi possível salvar estado:', e); }
    }
    function clearSavedState(){
      try { localStorage.removeItem(STORAGE_KEY); } catch(e){/* ignore */ }
    }
    function restoreStateIfAny(){
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if(!raw) return false;
        const s = JSON.parse(raw);
        if (s.wordListRaw && wordListEl) wordListEl.value = s.wordListRaw;
        words = Array.isArray(s.words) ? s.words.slice() : (s.wordListRaw ? s.wordListRaw.split(/\r?\n/).map(w=>w.trim()).filter(Boolean) : []);
        index = typeof s.index === 'number' ? s.index : 0;
        errorMode = !!s.errorMode;
        wrongGenerations = Array.isArray(s.wrongGenerations) ? s.wrongGenerations.map(g => Array.isArray(g) ? g.slice() : []) : [];
        currentMarkedWrongWords = Array.isArray(s.currentMarkedWrongWords) ? s.currentMarkedWrongWords.slice() : [];
        reviewMarkedWrongWords = Array.isArray(s.reviewMarkedWrongWords) ? s.reviewMarkedWrongWords.slice() : [];
        currentGenerationIndex = typeof s.currentGenerationIndex === 'number' ? s.currentGenerationIndex : -1;
        lastReviewedGenerationIndex = typeof s.lastReviewedGenerationIndex === 'number' ? s.lastReviewedGenerationIndex : -1;
        isReviewMode = !!s.isReviewMode;
        pendingLaunch = !!s.pendingLaunch;
        lastLoadedMain = typeof s.lastLoadedMain === 'number' ? s.lastLoadedMain : (words && words.length) || 0;
        lastLoadedWrong = typeof s.lastLoadedWrong === 'number' ? s.lastLoadedWrong : (wrongGenerations.length ? wrongGenerations[wrongGenerations.length-1].length : 0);
        narratorEnabled = !!s.narratorEnabled;
        announceNextEnabled = !!s.announceNextEnabled;
        blurOn = !!s.blurOn;

        applyRestoredStateToUI();
        return true;
      } catch(e){ console.warn('Falha ao restaurar estado:', e); return false; }
    }

    function applyRestoredStateToUI(){
      if (narratorToggle) narratorToggle.checked = !!narratorEnabled;
      if (announceNextToggle) announceNextToggle.checked = !!announceNextEnabled;
      if (toggleErrorBtn) setErrorToggleVisual(!!errorMode);

      lastLoadedMain = lastLoadedMain || (words && words.length) || 0;
      if (totalCountDisplay) totalCountDisplay.textContent = `Carregadas: ${lastLoadedMain}`;
      if (wordListEl && (!wordListEl.value || wordListEl.value.trim() === '')) {
        if (words && words.length) wordListEl.value = words.join('\n');
      }
      if (pendingLaunch) {
        if (currentWordEl) currentWordEl.textContent = '';
      } else {
        if (words && words.length && words[index]) {
          if (currentWordEl) currentWordEl.textContent = words[index];
        } else {
          if (currentWordEl) currentWordEl.textContent = '';
        }
      }
      if (blurOn && currentWordEl) currentWordEl.classList.add('blurred'); else if (currentWordEl) currentWordEl.classList.remove('blurred');

      if (startBtn) startBtn.disabled = !(words && words.length);
      if (shuffleBtn) shuffleBtn.disabled = !(words && words.length);
      if (prevBtn) prevBtn.disabled = !(words && words.length && index > 0);
      if (nextBtn) nextBtn.disabled = true;
      if (repeatBtn) repeatBtn.disabled = !narratorEnabled;

      renderWrongWords();

      if (pendingLaunch && errorListSection && currentGenerationIndex >= 0) {
        errorListSection.style.display = 'block';
        if (errorListArea && wrongGenerations[currentGenerationIndex]) errorListArea.value = wrongGenerations[currentGenerationIndex].join('\n');
      } else if (errorListSection) {
        if (wrongGenerations && wrongGenerations.length && currentGenerationIndex >= 0) {
          errorListSection.style.display = 'block';
          if (errorListArea) errorListArea.value = wrongGenerations[currentGenerationIndex].join('\n');
        } else {
          errorListSection.style.display = 'none';
        }
      }

      updateWordCounter();
      updateButtonStates();
    }

    /* ========== Helpers visuais e timer (mantidos) ========== */
    function speakWithPromise(text, { interrupt = true, fallbackMs = 1200, allowWhenNarratorOff = false } = {}) {
      return new Promise((resolve) => {
        if (!narratorEnabled && !allowWhenNarratorOff) { resolve(); return; }
        try { if (interrupt) speechSynthesis.cancel(); } catch(e){}
        const u = new SpeechSynthesisUtterance(text); u.lang = 'pt-BR';
        let finished = false;
        const guard = setTimeout(() => { if (!finished) { finished = true; resolve(); } }, fallbackMs + 400);
        u.onend = u.onerror = () => { if (!finished) { finished = true; clearTimeout(guard); resolve(); } };
        try { speechSynthesis.speak(u); } catch (e) { clearTimeout(guard); resolve(); }
      });
    }

    function showInactiveClock() {
      if (!inactiveClock) return;
      inactiveClock.classList.remove('hidden');
      inactiveClock.classList.add('visible');
      const svg = document.getElementById('countdownSvg');
      if (svg) svg.style.display = 'none';
      if (centerSeconds) centerSeconds.textContent = '-';
      if (progressCircle) {
        progressCircle.style.transition = 'none';
        progressCircle.style.strokeDashoffset = `${CIRC}`;
        progressCircle.style.stroke = colorLerp(startColor,endColor,0);
      }
    }
    function hideInactiveClock() {
      if (!inactiveClock) return;
      inactiveClock.classList.remove('visible');
      inactiveClock.classList.add('hidden');
      const svg = document.getElementById('countdownSvg');
      if (svg) svg.style.display = 'block';
    }
    function animateClockToRingThenStart(callback) {
      if (!inactiveClock) return;
      inactiveClock.classList.remove('visible');
      inactiveClock.classList.remove('hidden');
      inactiveClock.classList.add('anim-to-ring');
      setTimeout(() => {
        inactiveClock.classList.add('hidden');
        inactiveClock.classList.remove('anim-to-ring');
        const svg = document.getElementById('countdownSvg');
        if (svg) svg.style.display = 'block';
        if (progressCircle) {
          progressCircle.style.stroke = colorLerp(startColor, endColor, 0);
          progressCircle.classList.add('progress-transition');
          progressCircle.style.strokeDashoffset = `${CIRC}`;
        }
        if (typeof callback === 'function') callback();
      }, 520);
    }

    function setAutoArmedVisual(on){
      if(!autoBtn) return;
      if(on){ autoBtn.classList.remove('btn-outline-success'); autoBtn.classList.add('btn-success','pulse'); }
      else { autoBtn.classList.remove('btn-success','pulse'); autoBtn.classList.add('btn-outline-success'); }
      if(on) showMainTimerProxies(); else hideMainTimerProxies();
      if(!on) statusEl.textContent = 'Timer Desativado'; else statusEl.textContent = 'Timer Pronto';
    }
    function setAutoRunningVisual(on){
      if(!autoBtn) return;
      if(on){ autoBtn.classList.remove('btn-outline-success'); autoBtn.classList.add('btn-success','pulse'); }
      else { autoBtn.classList.remove('btn-success','pulse'); autoBtn.classList.add('btn-outline-success'); }
    }
    function setPauseVisual(paused){
      if(!pauseProxy) return;
      if(paused){ pauseProxy.classList.remove('btn-outline-warning'); pauseProxy.classList.add('btn-warning','active'); pauseProxy.innerHTML = '<i class="bi bi-play-fill me-1"></i> Retomar'; }
      else { pauseProxy.classList.remove('btn-warning','active'); pauseProxy.classList.add('btn-outline-warning'); pauseProxy.innerHTML = '<i class="bi bi-pause-fill me-1"></i> Pausar'; }
    }

    function setErrorToggleVisual(on){
      if(!toggleErrorBtn) return;
      if(on){ toggleErrorBtn.classList.remove('btn-outline-danger'); toggleErrorBtn.classList.add('btn-danger','btn-err-active'); toggleErrorBtn.textContent = 'Registro Ativo'; }
      else { toggleErrorBtn.classList.remove('btn-danger','btn-err-active'); toggleErrorBtn.classList.add('btn-outline-danger'); toggleErrorBtn.textContent = 'Registrar Erradas (↓)'; }
      if(on) showMainErrorProxies(); else hideMainErrorProxies();
    }

    function clearCountdown(){
      if(endTimer){ clearTimeout(endTimer); endTimer=null; }
      if(tickInterval){ clearInterval(tickInterval); tickInterval=null; }
      if(ringRaf){ cancelAnimationFrame(ringRaf); ringRaf=null; }
      ringStartTime=null; ringDuration=null;
      if (progressCircle) {
        progressCircle.style.transition = 'stroke-dashoffset 240ms linear, stroke 240ms linear';
        progressCircle.style.strokeDashoffset = `${CIRC}`;
        progressCircle.style.stroke = colorLerp(startColor, endColor, 0);
      }
      if (centerSeconds) centerSeconds.textContent = '-';
      if (timerDisplay) timerDisplay.textContent = '';
    }

    function setCountdownFor(sec){
      if(pendingLaunch){ clearCountdown(); return; }
      clearCountdown();
      remainingSec = Math.max(1, Math.floor(sec) || 1);
      ringDuration = remainingSec * 1000;
      ringStartTime = performance.now();
      if (progressCircle) progressCircle.style.transition='none';
      if (progressCircle) {
        progressCircle.style.stroke = colorLerp(startColor, endColor, 0);
        progressCircle.style.strokeDashoffset = `${CIRC}`;
      }
      updateCenterSeconds(remainingSec);
      if (timerDisplay) timerDisplay.textContent = `Próxima em: ${remainingSec}s`;
      endTimer = setTimeout(()=>{ clearCountdown(); announceThenAdvance(); }, ringDuration);
      tickInterval = setInterval(()=>{
        if(isPaused) return;
        const elapsedMs = performance.now() - ringStartTime;
        const remMs = Math.max(0, ringDuration - elapsedMs);
        const rem = Math.ceil(remMs / 1000);
        updateCenterSeconds(rem);
        if (timerDisplay) timerDisplay.textContent = `Próxima em: ${rem}s`;
      },150);
      function step(now){
        if(!ringStartTime || isPaused){ ringRaf = requestAnimationFrame(step); return; }
        const elapsedMs = now - ringStartTime;
        const progress = Math.min(1, elapsedMs / ringDuration);
        const offset = CIRC * (1 - progress);
        if (progressCircle) {
          progressCircle.style.strokeDashoffset = `${offset}`;
          progressCircle.style.stroke = colorLerp(startColor, endColor, progress);
        }
        if (progress < 1) ringRaf = requestAnimationFrame(step);
        else { if (progressCircle) { progressCircle.style.strokeDashoffset = `0`; progressCircle.style.stroke = colorLerp(startColor,endColor,1); } }
      }
      ringRaf = requestAnimationFrame(step);
    }

    function updateCenterSeconds(n){ if (centerSeconds) centerSeconds.textContent = `${n}s`; }

    // Helper: controla disponibilidade do botão "Adicionar Errada"
    function updateAddWrongAvailability(){
      if(!addWrongProxy) return;
      const hasWord = currentWordEl && currentWordEl.textContent && currentWordEl.textContent.trim();
      addWrongProxy.disabled = !(errorMode && !pendingLaunch && !!hasWord);
    }

    // UPDATED: update word counter display with robust logic for main / pendingLaunch / review
    function updateWordCounter(){
      const current = (typeof index === 'number' && words && words.length) ? Math.min(index + 1, words.length) : 0;
      let total = 0;
      if (isReviewMode || pendingLaunch) {
        total = (words && words.length) ? words.length : (lastLoadedWrong || 0);
      } else {
        total = lastLoadedMain || (words && words.length) || 0;
      }
      if (wordCounterEl) wordCounterEl.textContent = `${current} / ${total || 0}`;
      updateAddWrongAvailability();
      updateButtonStates(); // ensure prev/next states also refreshed
    }

    // IMPORTANT FIX: synchronize prev/next without depending on dictationRunning
    function updateButtonStates(){
      const hasWords = words && words.length;
      const canPrev = hasWords && index > 0 && !pendingLaunch;
      const canNext = hasWords && index < (words.length - 1) && !pendingLaunch;
      if (prevBtn) prevBtn.disabled = !canPrev;
      if (nextBtn) nextBtn.disabled = !canNext;
    }

    function speakAndShow(text){
      if (currentWordEl) {
        currentWordEl.textContent = text || '';
        if (blurOn) currentWordEl.classList.add('blurred'); else currentWordEl.classList.remove('blurred');
      }
      updateWordCounter();
      if (!narratorEnabled) return;
      try { speechSynthesis.cancel(); } catch(e){}
      const u = new SpeechSynthesisUtterance(text); u.lang='pt-BR';
      speechSynthesis.speak(u);
    }

    async function announceThenAdvance(){
      if(awaitingAnnouncement) return;
      if(pendingLaunch){ awaitingAnnouncement=false; return; }
      awaitingAnnouncement = true;
      try {
        try{ speechSynthesis.cancel(); } catch(e){}
        if (announceNextEnabled) {
          await speakWithPromise('Próxima palavra', { interrupt:true, fallbackMs:900, allowWhenNarratorOff:true });
        }
      } catch(e){}
      finally {
        awaitingAnnouncement = false;
        if(!isPaused && !pendingLaunch) advanceDictation();
        else if (timerDisplay) timerDisplay.textContent='';
      }
    }

    // dictation flow
    function beginDictation(){
      dictationRunning = true; index = 0; awaitingAnnouncement = false;
      if (words[index]) speakAndShow(words[index]);
      if(nextBtn) nextBtn.disabled = false;
      if(startBtn) startBtn.disabled = true;
      isPaused = false;
      setPauseVisual(false);
      if (pauseProxy) pauseProxy.classList.add('hidden');
      if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
      updateAddWrongAvailability();
      updateButtonStates();
      saveState();
    }

    function advanceDictation(fromManual=false){
      index++;
      if(index < words.length){
        speakAndShow(words[index]);
        if (prevBtn) prevBtn.disabled = false;
        if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
      } else finishDictation();
      updateButtonStates();
      saveState();
    }

    function finishDictation(){
      dictationRunning = false;
      clearCountdown();

      let total = 0;
      let wrongCount = 0;
      if (isReviewMode) {
        total = words.length || lastLoadedWrong || 0;
        wrongCount = reviewMarkedWrongWords.length;
      } else {
        total = lastLoadedMain || words.length || 0;
        wrongCount = currentMarkedWrongWords.length;
      }
      let accuracy = 0;
      if (total > 0) accuracy = Math.round(((total - wrongCount) / total) * 1000) / 10;

      if (isReviewMode) {
        alert('Revisão concluída!');
        statusEl.textContent = `Revisão concluída — total: ${total} | erradas geradas: ${wrongCount} | acerto: ${accuracy}%`;
      } else {
        alert('Ditado concluído!');
        statusEl.textContent = `Lista concluída — total: ${total} | erradas: ${wrongCount} | acerto: ${accuracy}%`;
      }

      if (isReviewMode) {
        if (reviewMarkedWrongWords.length > 0) {
          wrongGenerations.push(reviewMarkedWrongWords.slice());
          lastLoadedWrong = reviewMarkedWrongWords.length;
          currentMarkedWrongWords = wrongGenerations[wrongGenerations.length - 1].slice();
        } else {
          lastLoadedWrong = currentMarkedWrongWords.length || 0;
        }
        lastReviewedGenerationIndex = currentGenerationIndex;
        canShowRedo = lastReviewedGenerationIndex >= 0;
        if (errorListSection) {
          errorListSection.style.display = 'block';
          if (errorListArea && currentGenerationIndex >=0 && wrongGenerations[currentGenerationIndex]) {
            errorListArea.value = wrongGenerations[currentGenerationIndex].join('\n');
          } else if (errorListArea) {
            errorListArea.value = wrongGenerations[wrongGenerations.length - 2] ? wrongGenerations[wrongGenerations.length - 2].join('\n') : '';
          }
        }
        reviewMarkedWrongWords = [];
        isReviewMode = false;
      } else {
        if (currentMarkedWrongWords.length > 0) {
          wrongGenerations.push(currentMarkedWrongWords.slice());
          lastLoadedWrong = currentMarkedWrongWords.length;
        }
        canShowRedo = false;
      }

      if (currentWordEl) currentWordEl.textContent='';
      updateWordCounter();
      if (nextBtn) nextBtn.disabled=true;
      if (prevBtn) prevBtn.disabled=true;
      if (startBtn) startBtn.disabled=false;
      if (shuffleBtn) shuffleBtn.disabled=false;
      isAuto = false; isPaused = false; pendingLaunch = false;
      if (autoArmed) showStartTimerProxy(); else hideMainTimerProxies();

      if (errorMode || (currentMarkedWrongWords && currentMarkedWrongWords.length > 0) || (wrongGenerations && wrongGenerations.length > 0)) {
        showMainErrorProxies();
      } else {
        hideMainErrorProxies();
      }

      showInactiveClock();
      renderWrongWords();
      updateAddWrongAvailability();
      updateButtonStates();
      saveState();
    }

    function pauseAuto(){
      if(!isAuto || isPaused) return;
      isPaused = true;
      if(ringStartTime && ringDuration){
        const elapsedMs = performance.now() - ringStartTime;
        const remMs = Math.max(0, ringDuration - elapsedMs);
        remainingSec = Math.max(0, Math.ceil(remMs / 1000));
      } else remainingSec = Math.max(1, remainingSec || 1);
      clearCountdown();
      try { speechSynthesis.cancel(); } catch(e){}
      awaitingAnnouncement = false;
      if (statusEl) statusEl.textContent = `Automático pausado. ${remainingSec}s restantes.`;
      setPauseVisual(true);
    }

    function resumeAuto(){
      if(!isAuto || !isPaused) return;
      isPaused = false;
      setPauseVisual(false);
      if (statusEl) statusEl.textContent = 'Automático retomado.';
      try { speechSynthesis.cancel(); } catch(e){}
      if (words[index]) speakAndShow(words[index]);
      const secToUse = Math.max(1, remainingSec || 1);
      if(!pendingLaunch) setCountdownFor(secToUse); else clearCountdown();
    }

    // proxies visibility
    function showMainTimerProxies(){
      const area = document.getElementById('mainTimerProxies');
      if (!area) return;
      area.classList.remove('hidden'); area.setAttribute('aria-hidden','false');
      showStartTimerProxy();
    }
    function hideMainTimerProxies(){
      const area = document.getElementById('mainTimerProxies');
      if (!area) return;
      area.classList.add('hidden'); area.setAttribute('aria-hidden','true');
      if (startTimerProxy) startTimerProxy.classList.add('hidden');
      if (pauseProxy) pauseProxy.classList.add('hidden');
    }
    function showStartTimerProxy(){
      if (!startTimerProxy) return;
      startTimerProxy.classList.remove('hidden');
      if (pauseProxy) pauseProxy.classList.add('hidden');
    }
    function hideStartTimerProxy(){
      if (startTimerProxy) return;
    }

    function showMainErrorProxies(){
      const area = document.getElementById('mainErrorProxies');
      if (!area) return;
      area.classList.remove('hidden'); area.setAttribute('aria-hidden','false');
      if (addWrongProxy) addWrongProxy.classList.remove('hidden');
      if (startErrorProxy) startErrorProxy.classList.remove('hidden');
      if (clearErrorProxy) clearErrorProxy.classList.remove('hidden');

      if (redoWrongProxy) {
        if (canShowRedo && !isReviewMode) {
          redoWrongProxy.classList.remove('hidden');
          redoWrongProxy.classList.add('redo-appear');
          setTimeout(()=>{ if (redoWrongProxy) redoWrongProxy.classList.remove('redo-appear'); }, 700);
        } else {
          redoWrongProxy.classList.add('hidden');
          redoWrongProxy.classList.remove('redo-appear');
        }
      }

      if(pendingLaunch && launchErrorProxy) launchErrorProxy.classList.remove('hidden'); else if (launchErrorProxy) launchErrorProxy.classList.add('hidden');

      updateAddWrongAvailability();
    }
    function hideMainErrorProxies(){
      const area = document.getElementById('mainErrorProxies');
      if (!area) return;
      area.classList.add('hidden'); area.setAttribute('aria-hidden','true');
      if (addWrongProxy) addWrongProxy.classList.add('hidden');
      if (startErrorProxy) startErrorProxy.classList.add('hidden');
      if (launchErrorProxy) launchErrorProxy.classList.add('hidden');
      if (clearErrorProxy) clearErrorProxy.classList.add('hidden');
      if (redoWrongProxy) { redoWrongProxy.classList.add('hidden'); redoWrongProxy.classList.remove('redo-appear'); }
    }

    // Render errado UI
    function renderWrongWords(){
      const arr = isReviewMode ? reviewMarkedWrongWords : currentMarkedWrongWords;
      wrongWordsList.innerHTML = (arr||[]).map(w => `<span class="chip" role="button" tabindex="0" data-word="${encodeURIComponent(w)}">${w} <i class="bi bi-x-lg ms-1" aria-hidden="true"></i></span>`).join('');
      startErrorProxy.disabled = !((currentMarkedWrongWords && currentMarkedWrongWords.length) || (wrongGenerations && wrongGenerations.length));
      clearErrorProxy.disabled = !((currentMarkedWrongWords && currentMarkedWrongWords.length) || (wrongGenerations && wrongGenerations.length));
      wrongSection.style.display = ( (arr && arr.length>0) || errorMode ) ? 'block' : 'none';
      updateWordCounter();
    }

    // copy icon timers (for visual feedback)
    let _copyIconTimers = { colorTimer: null, resetTimer: null };

    function clearCopyIconTimersAndRestore(){
      try {
        if (_copyIconTimers.colorTimer) { clearTimeout(_copyIconTimers.colorTimer); _copyIconTimers.colorTimer = null; }
        if (_copyIconTimers.resetTimer) { clearTimeout(_copyIconTimers.resetTimer); _copyIconTimers.resetTimer = null; }
        if (copyErrorListBtn) {
          const iconEl = copyErrorListBtn.querySelector('i');
          if (iconEl) {
            iconEl.className = 'bi bi-clipboard';
            iconEl.classList.remove('copy-success');
            iconEl.style.color = '';
          }
        }
      } catch(e){ /* swallow */ }
    }

    // Central add wrong helper - robust and used by button and keyboard
    function addCurrentWordAsWrong(){
      if (pendingLaunch) { statusEl.textContent = 'Finalize "Iniciar Erradas" antes de marcar palavras.'; return; }
      const cur = currentWordEl && currentWordEl.textContent ? currentWordEl.textContent.trim() : '';
      if (!cur) return;
      if (!errorMode) return;
      if (isReviewMode) {
        if (!reviewMarkedWrongWords.includes(cur)) {
          reviewMarkedWrongWords.push(cur);
          statusEl.textContent = `"${cur}" adicionada às erradas (revisão).`;
          saveState();
        } else {
          statusEl.textContent = `"${cur}" já está nas erradas (revisão).`;
        }
      } else {
        if (!currentMarkedWrongWords.includes(cur)) {
          currentMarkedWrongWords.push(cur);
          statusEl.textContent = `"${cur}" adicionada às erradas.`;
          saveState();
        } else {
          statusEl.textContent = `"${cur}" já está nas erradas.`;
        }
      }
      renderWrongWords();
      updateAddWrongAvailability();
    }

    // === Eventos e comportamentos principais ===
    (function attachListeners(){
      // Auto (menu)
      if (autoBtn) autoBtn.addEventListener('click', () => {
        autoArmed = !autoArmed;
        setAutoArmedVisual(autoArmed);
        if (autoArmed) {
          if (statusEl) statusEl.textContent = 'Timer Pronto';
          showInactiveClock();
        } else {
          if (statusEl) statusEl.textContent = 'Timer Desativado';
          if (isAuto) { isAuto=false; isPaused=false; clearCountdown(); }
          showInactiveClock();
        }
      });

      // iniciar timer proxy
      if (startTimerProxy) startTimerProxy.addEventListener('click', () => {
        if (!autoArmed) { if (statusEl) statusEl.textContent = 'Ative Automático no menu de Opções primeiro.'; return; }
        if (!words || words.length === 0) { if (statusEl) statusEl.textContent = 'Carregue palavras antes de iniciar o timer.'; return; }
        if (!dictationRunning) { if (statusEl) statusEl.textContent = 'Inicie o ditado (botão "Iniciar") antes de ativar o timer.'; return; }

        isAuto = true; isPaused = false;
        setAutoRunningVisual(true);
        if (statusEl) statusEl.textContent = 'Timer iniciado.';
        hideStartTimerProxy();
        if (pauseProxy) pauseProxy.classList.remove('hidden');

        animateClockToRingThenStart(() => {
          setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
        });
      });

      // pause proxy
      if (pauseProxy) pauseProxy.addEventListener('click', () => { if(!isAuto) return; if(isPaused) resumeAuto(); else pauseAuto(); });

      // interval change
      if (intervalInputProxy) intervalInputProxy.addEventListener('change', (e) => { if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10))); });

      // add wrong (button)
      if (addWrongProxy) addWrongProxy.addEventListener('click', () => addCurrentWordAsWrong());

      // startErrorProxy: prepara a revisão a partir das erradas atuais
      if (startErrorProxy) startErrorProxy.addEventListener('click', () => {
        let listToUse = (currentMarkedWrongWords && currentMarkedWrongWords.length) ? currentMarkedWrongWords.slice() : [];
        if (!listToUse.length && wrongGenerations.length) listToUse = wrongGenerations[wrongGenerations.length - 1].slice();
        if (!listToUse.length) return alert('Não há palavras erradas para iniciar a revisão.');
        wrongGenerations.push(listToUse.slice());
        currentGenerationIndex = wrongGenerations.length - 1;
        canShowRedo = false;
        if (redoWrongProxy) { redoWrongProxy.classList.add('hidden'); redoWrongProxy.classList.remove('redo-appear'); }

        lastLoadedWrong = listToUse.length;
        words = [...listToUse];
        index = 0;
        statusEl.textContent = 'Preparado: pronto para iniciar revisão das erradas.';
        pendingLaunch = true;
        try{ speechSynthesis.cancel(); }catch(e){}
        clearCountdown(); awaitingAnnouncement = false;
        if (launchErrorProxy) launchErrorProxy.classList.remove('hidden');
        currentMarkedWrongWords = [];
        if (errorListSection) { errorListSection.style.display = 'block'; if (errorListArea) errorListArea.value = wrongGenerations[currentGenerationIndex].join('\n'); }
        if (currentWordEl) currentWordEl.textContent = '';
        updateAddWrongAvailability();
        renderWrongWords();
        updateWordCounter();
        updateButtonStates();
        saveState();
      });

      // launchErrorProxy: inicia a revisão
      if (launchErrorProxy) launchErrorProxy.addEventListener('click', () => {
        canShowRedo = false;
        if (redoWrongProxy) { redoWrongProxy.classList.add('hidden'); redoWrongProxy.classList.remove('redo-appear'); }

        launchErrorProxy.classList.add('hidden');
        index = 0;
        statusEl.textContent = 'Ditado de erradas iniciado.';
        pendingLaunch = false;
        if (prevBtn) prevBtn.disabled = false;
        if (errorListSection) errorListSection.style.display = 'block';
        if (errorListArea && currentGenerationIndex >=0) errorListArea.value = wrongGenerations[currentGenerationIndex].join('\n');
        reviewMarkedWrongWords = [];
        isReviewMode = true;
        renderWrongWords();
        updateWordCounter();
        beginDictation();
        updateAddWrongAvailability();
        if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
        saveState();
      });

      // clear error proxy: apaga tudo (gerações e marcas)
      if (clearErrorProxy) clearErrorProxy.addEventListener('click', () => {
        currentMarkedWrongWords = []; wrongGenerations = []; reviewMarkedWrongWords = [];
        currentGenerationIndex = -1; lastReviewedGenerationIndex = -1; lastLoadedWrong = 0;
        renderWrongWords();
        if (errorListSection) errorListSection.style.display = 'none';
        if (wrongSection) wrongSection.style.display = 'none';
        pendingLaunch = false; if (launchErrorProxy) launchErrorProxy.classList.add('hidden'); hideMainErrorProxies();
        canShowRedo = false;
        updateWordCounter();
        updateAddWrongAvailability();
        clearCopyIconTimersAndRestore();
        saveState();
      });

      // redoWrongProxy: refazer a geração revisada (deleta as gerações filhas)
      if (redoWrongProxy) redoWrongProxy.addEventListener('click', () => {
        if (lastReviewedGenerationIndex < 0) return alert('Nenhuma revisão finalizada para refazer.');
        if (wrongGenerations.length > lastReviewedGenerationIndex + 1) {
          wrongGenerations.splice(lastReviewedGenerationIndex + 1);
        }
        currentGenerationIndex = lastReviewedGenerationIndex;
        words = (wrongGenerations[currentGenerationIndex] || []).slice();
        reviewMarkedWrongWords = [];
        isReviewMode = true;
        canShowRedo = false;
        index = 0;
        statusEl.textContent = 'Refazendo erradas: lista resetada. Revisão iniciada.';
        if (errorListSection) errorListSection.style.display = 'block';
        if (errorListArea) errorListArea.value = words.join('\n');
        try{ speechSynthesis.cancel(); }catch(e){}
        beginDictation();
        if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
        renderWrongWords();
        updateWordCounter();
        saveState();
      });

      // load list principal
      if (loadBtn) loadBtn.addEventListener('click', () => {
        const raw = (wordListEl && wordListEl.value || '').trim();
        if(!raw) return alert('Insira ao menos uma palavra.');
        words = raw.split(/\r?\n/).map(w => w.trim()).filter(Boolean);
        index = 0; isAuto = false; isPaused = false;

        // Reset completo das erradas/revisões (mas manter o toggle errorMode ativo/deativo como estava)
        currentMarkedWrongWords = []; reviewMarkedWrongWords = []; wrongGenerations = [];
        currentGenerationIndex = -1; lastReviewedGenerationIndex = -1;
        lastLoadedWrong = 0;
        pendingLaunch = false;
        canShowRedo = false;

        // UI resets
        if (startBtn) startBtn.disabled = false;
        if (shuffleBtn) shuffleBtn.disabled = false;
        if (prevBtn) prevBtn.disabled = true;
        if (nextBtn) nextBtn.disabled = true;
        if (currentWordEl) currentWordEl.textContent = '';
        clearCountdown();
        lastLoadedMain = words.length;
        if (totalCountDisplay) totalCountDisplay.textContent = `Carregadas: ${lastLoadedMain}`;
        statusEl.textContent = `Lista carregada: ${words.length} palavras.`;

        // Show/hide errada UI according to toggle state — important: keep toggle state but "clean"
        setErrorToggleVisual(errorMode);
        if (!errorMode) {
          if (wrongSection) wrongSection.style.display = 'none';
          if (errorListSection) errorListSection.style.display = 'none';
        } else {
          // when active, ensure UI is visible but empty
          if (wrongSection) wrongSection.style.display = 'block';
          if (errorListSection) errorListSection.style.display = 'none';
        }

        if (launchErrorProxy) launchErrorProxy.classList.add('hidden');
        renderWrongWords();
        pendingLaunch = false;
        updateWordCounter();
        setPauseVisual(false);
        if (pauseProxy) pauseProxy.classList.add('hidden');
        if (autoArmed) { showStartTimerProxy(); showInactiveClock(); } else { hideMainTimerProxies(); showInactiveClock(); }
        if (redoWrongProxy) { redoWrongProxy.classList.add('hidden'); redoWrongProxy.classList.remove('redo-appear'); }

        // Clear saved state because loading a new list invalidates previous session
        clearSavedState();

        // Restore copy icon and timers
        clearCopyIconTimersAndRestore();
      });

      // shuffle
      if (shuffleBtn) shuffleBtn.addEventListener('click', () => {
        // preserve toggle state but reset erradas
        currentMarkedWrongWords = [];
        reviewMarkedWrongWords = [];
        wrongGenerations = [];
        currentGenerationIndex = -1;
        lastReviewedGenerationIndex = -1;
        lastLoadedWrong = 0;
        canShowRedo = false;
        pendingLaunch = false;
        if (redoWrongProxy) { redoWrongProxy.classList.add('hidden'); redoWrongProxy.classList.remove('redo-appear'); }
        if (errorListSection) errorListSection.style.display = 'none';
        if (wrongSection) wrongSection.style.display = 'none';
        if (launchErrorProxy) launchErrorProxy.classList.add('hidden');
        renderWrongWords();

        for (let i = words.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [words[i], words[j]] = [words[j], words[i]];
        }
        index = 0;
        if (statusEl) statusEl.textContent = 'Lista embaralhada.';
        updateAddWrongAvailability();
        updateWordCounter();

        // shuffle invalidates saved session
        clearSavedState();

        // restore copy icon
        clearCopyIconTimersAndRestore();

        // Ensure UI reflects toggle state (clean)
        setErrorToggleVisual(errorMode);
        updateButtonStates();
      });

      // reset all application
      if (resetBtn) resetBtn.addEventListener('click', () => {
        // **Important change:** Reset truly clears everything, including the errorMode toggle
        // and all options (Timer, Ditado de Erradas, Narrador) — factory defaults.
        words = []; index = 0;
        currentMarkedWrongWords = []; reviewMarkedWrongWords = []; wrongGenerations = [];
        currentGenerationIndex = -1; lastReviewedGenerationIndex = -1;
        lastLoadedMain = 0; lastLoadedWrong = 0;
        isReviewMode = false; pendingLaunch = false; canShowRedo = false;
        dictationRunning = false;
        isAuto = false; isPaused = false; autoArmed = false;

        // Reset narrator and announce toggles to factory defaults (enabled)
        narratorEnabled = true; announceNextEnabled = true;
        if (narratorToggle) {
          narratorToggle.checked = true;
          const label = narratorToggle.nextElementSibling;
          if (label) label.textContent = 'Narrador (ativado)';
        }
        if (announceNextToggle) {
          announceNextToggle.checked = true;
          const label2 = announceNextToggle.nextElementSibling;
          if (label2) label2.textContent = 'Falar "Próxima palavra" (ativado)';
        }
        if (repeatBtn) repeatBtn.disabled = !narratorEnabled;

        // UI resets
        if (wordListEl) wordListEl.value = '';
        if (currentWordEl) currentWordEl.textContent = '';
        if (totalCountDisplay) totalCountDisplay.textContent = `Carregadas: 0`;
        if (wrongSection) wrongSection.style.display = 'none';
        if (errorListSection) errorListSection.style.display = 'none';
        if (launchErrorProxy) launchErrorProxy.classList.add('hidden');
        hideMainErrorProxies();
        hideMainTimerProxies();
        showInactiveClock();
        if (startBtn) startBtn.disabled = true;
        if (shuffleBtn) shuffleBtn.disabled = true;
        if (prevBtn) prevBtn.disabled = true;
        if (nextBtn) nextBtn.disabled = true;
        setPauseVisual(false);

        // Reset the toggle: now it becomes deactivated
        errorMode = false;
        setErrorToggleVisual(false);

        // Reset auto armed visual and narrator visuals
        setAutoArmedVisual(false);

        // clear saved state and timers
        clearSavedState();
        clearCountdown();
        clearCopyIconTimersAndRestore();
        renderWrongWords();
        updateWordCounter();
        statusEl.textContent = 'Aplicação resetada.';
      });

      // start ditado principal (com aviso se houver revisões/erradas)
      if (startBtn) startBtn.addEventListener('click', () => {
        if(!words.length) return;
        if (isReviewMode || pendingLaunch || (wrongGenerations && wrongGenerations.length > 0) || (currentMarkedWrongWords && currentMarkedWrongWords.length > 0)) {
          const ok = confirm('Ao iniciar a lista principal todas as revisões/erradas em andamento serão reiniciadas. Deseja continuar?');
          if (!ok) return;

          // Reset erradas/generaçoes but KEEP the toggle state (clean)
          currentMarkedWrongWords = [];
          reviewMarkedWrongWords = [];
          wrongGenerations = [];
          currentGenerationIndex = -1;
          lastReviewedGenerationIndex = -1;
          lastLoadedWrong = 0;
          canShowRedo = false;
          pendingLaunch = false;

          // Update UI so toggle remains consistent and "clean"
          setErrorToggleVisual(errorMode);
          if (!errorMode) {
            if (errorListSection) errorListSection.style.display = 'none';
            if (wrongSection) wrongSection.style.display = 'none';
            hideMainErrorProxies();
          } else {
            // show proxies and empty wrong section
            if (wrongSection) wrongSection.style.display = 'block';
            showMainErrorProxies();
            if (errorListSection) errorListSection.style.display = 'none';
          }

          if (redoWrongProxy) { redoWrongProxy.classList.add('hidden'); redoWrongProxy.classList.remove('redo-appear'); }
        }
        if (wrongSection) wrongSection.style.display='none';
        if (errorListSection) errorListSection.style.display='none';
        isReviewMode = false;
        canShowRedo = false;
        beginDictation();
        if (shuffleBtn) shuffleBtn.disabled = true;
        if (prevBtn) prevBtn.disabled = false;
        setPauseVisual(false);
        if (pauseProxy) pauseProxy.classList.add('hidden');
        if (autoArmed) showStartTimerProxy();
        updateAddWrongAvailability();
        updateWordCounter();
        saveState();
      });

      // toggle registrar erradas
      if (toggleErrorBtn) toggleErrorBtn.addEventListener('click', () => {
        errorMode = !errorMode;
        setErrorToggleVisual(errorMode);
        statusEl.textContent = errorMode ? 'Registro de erros ativado.' : 'Registro de erros desativado.';
        updateAddWrongAvailability();
        saveState();
      });

      // prev
      if (prevBtn) prevBtn.addEventListener('click', () => {
        if (index > 0) {
          index--;
          if (words[index]) speakAndShow(words[index]);
          if (nextBtn) nextBtn.disabled = false;
          if (isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
        }
        if (index === 0 && prevBtn) prevBtn.disabled = true;
        updateWordCounter();
        saveState();
      });

      // next
      if (nextBtn) nextBtn.addEventListener('click', () => { clearCountdown(); advanceDictation(true); updateWordCounter(); });

      // repeat
      if (repeatBtn) repeatBtn.addEventListener('click', () => {
        if (!words.length || !currentWordEl.textContent) return;
        if (narratorEnabled) {
          repeatBtn.classList.add('btn-rotate');
          try{ speechSynthesis.cancel(); }catch(e){}
          const u=new SpeechSynthesisUtterance(words[index]); u.lang='pt-BR';
          u.onend=()=>{ repeatBtn.classList.remove('btn-rotate'); };
          speechSynthesis.speak(u);
          setTimeout(()=>repeatBtn.classList.remove('btn-rotate'),1200);
        }
      });

      // blur toggle button
      if (blurToggleBtn) {
        blurToggleBtn.addEventListener('click', () => {
          blurOn = !blurOn;
          blurToggleBtn.setAttribute('aria-pressed', String(!!blurOn));
          if (blurOn) {
            blurIcon.classList.remove('bi-eye'); blurIcon.classList.add('bi-eye-slash');
            if (currentWordEl) currentWordEl.classList.add('blurred');
          } else {
            blurIcon.classList.remove('bi-eye-slash'); blurIcon.classList.add('bi-eye');
            if (currentWordEl) currentWordEl.classList.remove('blurred');
          }
          saveState();
        });
      }

      // keyboard shortcuts (inclui marcação por ArrowDown e novo toggle blur via ↑+↓)
      const keysDown = {};
      let lastBlurToggleTs = 0;
      document.addEventListener('keydown', (e) => {
        const active = document.activeElement && document.activeElement.tagName ? document.activeElement.tagName.toLowerCase() : '';
        // track keys
        keysDown[e.key] = true;

        // detect simultaneous ArrowUp + ArrowDown to toggle blur
        if (keysDown['ArrowUp'] && keysDown['ArrowDown']) {
          const now = Date.now();
          if (now - lastBlurToggleTs > 600) { // debounce 600ms
            e.preventDefault();
            blurOn = !blurOn;
            blurToggleBtn.setAttribute('aria-pressed', String(!!blurOn));
            if (blurOn) {
              blurIcon.classList.remove('bi-eye'); blurIcon.classList.add('bi-eye-slash');
              if (currentWordEl) currentWordEl.classList.add('blurred');
            } else {
              blurIcon.classList.remove('bi-eye-slash'); blurIcon.classList.add('bi-eye');
              if (currentWordEl) currentWordEl.classList.remove('blurred');
            }
            lastBlurToggleTs = now;
            saveState();
            return;
          }
        }

        if(active === 'input' || active === 'textarea') return;
        if(e.key === 'ArrowUp'){ e.preventDefault(); if(!repeatBtn.disabled) repeatBtn.click(); return; }

        if(errorMode && !pendingLaunch && e.key === 'ArrowDown' && currentWordEl && currentWordEl.textContent){
          e.preventDefault();
          addCurrentWordAsWrong();
          return;
        }

        if(e.key === 'ArrowRight'){ e.preventDefault(); if(!nextBtn.disabled) nextBtn.click(); } else if(e.key === 'ArrowLeft'){ e.preventDefault(); if(!prevBtn.disabled) prevBtn.click(); }
      });

      document.addEventListener('keyup', (e) => {
        // clear tracked key
        try { delete keysDown[e.key]; } catch(e){}
      });

      // clique para remover errada da lista exibida (usa data-word)
      if (wrongWordsList) wrongWordsList.addEventListener('click', (e) => {
        let target=e.target;
        while(target && !target.classList.contains('chip')) target = target.parentElement;
        if(!target) return;
        const encoded = target.dataset.word || '';
        const w = encoded ? decodeURIComponent(encoded) : target.textContent.trim().replace(/\s*×\s*$/,'').trim();
        if (isReviewMode) {
          const idx = reviewMarkedWrongWords.indexOf(w);
          if(idx >= 0) { reviewMarkedWrongWords.splice(idx,1); saveState(); }
        } else {
          const idx = currentMarkedWrongWords.indexOf(w);
          if(idx >= 0) { currentMarkedWrongWords.splice(idx,1); saveState(); }
        }
        renderWrongWords();
      });

      // copy error list button - NEW behavior with icon feedback
      if (copyErrorListBtn) copyErrorListBtn.addEventListener('click', async () => {
        let text = (errorListArea && errorListArea.value) ? errorListArea.value.trim() : '';
        if (!text && typeof currentGenerationIndex === 'number' && currentGenerationIndex >= 0 && wrongGenerations && wrongGenerations[currentGenerationIndex]) {
          text = wrongGenerations[currentGenerationIndex].join('\n');
        }
        if (!text && currentMarkedWrongWords && currentMarkedWrongWords.length) {
          text = currentMarkedWrongWords.join('\n');
        }
        if (!text) { alert('Não há palavras para copiar.'); return; }

        const iconEl = copyErrorListBtn.querySelector('i');
        if (iconEl) {
          const originalClass = iconEl.className || 'bi bi-clipboard';
          if (_copyIconTimers.colorTimer) { clearTimeout(_copyIconTimers.colorTimer); _copyIconTimers.colorTimer = null; }
          if (_copyIconTimers.resetTimer) { clearTimeout(_copyIconTimers.resetTimer); _copyIconTimers.resetTimer = null; }

          // set check (WHITE) immediately
          iconEl.className = 'bi bi-check-lg';
          iconEl.style.color = '#ffffff'; // branco imediato
          iconEl.classList.remove('copy-success');

          // after 1s -> green
          _copyIconTimers.colorTimer = setTimeout(() => {
            iconEl.classList.add('copy-success');
            iconEl.style.color = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#10b981';
            _copyIconTimers.colorTimer = null;
          }, 1000);

          // after 3s -> restore original
          _copyIconTimers.resetTimer = setTimeout(() => {
            iconEl.className = originalClass;
            iconEl.classList.remove('copy-success');
            iconEl.style.color = '';
            _copyIconTimers.resetTimer = null;
          }, 3000);
        }

        try {
          await navigator.clipboard.writeText(text);
          statusEl.textContent = 'Lista copiada para a área de transferência.';
          saveState();
          return;
        } catch (err) {
          // fallback
        }

        try {
          const wasHidden = (errorListSection && errorListSection.style.display === 'none');
          if (wasHidden && errorListSection) errorListSection.style.display = 'block';

          if (errorListArea) {
            if (!errorListArea.value && currentGenerationIndex >= 0 && wrongGenerations[currentGenerationIndex]) {
              errorListArea.value = wrongGenerations[currentGenerationIndex].join('\n');
            } else if (!errorListArea.value && currentMarkedWrongWords && currentMarkedWrongWords.length) {
              errorListArea.value = currentMarkedWrongWords.join('\n');
            }
            errorListArea.select();
            document.execCommand('copy');
            window.getSelection().removeAllRanges();
            statusEl.textContent = 'Lista copiada (método alternativo).';
            if (wasHidden && errorListSection) errorListSection.style.display = 'none';
            saveState();
            return;
          }

          alert('Não foi possível copiar automaticamente. Selecione o texto manualmente e copie.');
        } catch (e2) {
          alert('Não foi possível copiar automaticamente. Selecione o texto manualmente e copie.');
        }
      });

      // unlock audio
      const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
      const unlockAudioBtn = document.getElementById('unlockAudioBtn');
      if(unlockAudioBtn && isTouchDevice){
        unlockAudioBtn.classList.remove('d-none');
        unlockAudioBtn.addEventListener('click', async () => {
          try { if (narratorEnabled) await speakWithPromise('Áudio ativado', { interrupt:true, fallbackMs:700, allowWhenNarratorOff:true }); audioUnlocked=true; if (statusEl) statusEl.textContent='Áudio ativado para este dispositivo.'; } catch(e){ if (statusEl) statusEl.textContent='Não foi possível ativar áudio automaticamente.'; } finally { unlockAudioBtn.classList.add('d-none'); }
        });
      }

      // narrator toggles
      if (narratorToggle) narratorToggle.addEventListener('change', () => {
        narratorEnabled = !!narratorToggle.checked;
        const label = narratorToggle.nextElementSibling;
        if (label) label.textContent = narratorEnabled ? 'Narrador (ativado)' : 'Narrador (desativado)';
        if (statusEl) statusEl.textContent = narratorEnabled ? 'Narrador ativado.' : 'Narrador desativado.';
        if (repeatBtn) { repeatBtn.disabled = !narratorEnabled; repeatBtn.title = narratorEnabled ? 'Repetir palavra (Seta ↑)' : 'Repetir desativado (Narrador desligado)'; }
        saveState();
      });

      if (announceNextToggle) announceNextToggle.addEventListener('change', () => {
        announceNextEnabled = !!announceNextToggle.checked;
        const label = announceNextToggle.nextElementSibling;
        if (label) label.textContent = announceNextEnabled ? 'Falar "Próxima palavra" (ativado)' : 'Falar "Próxima palavra" (desativado)';
        if (statusEl) statusEl.textContent = announceNextEnabled ? 'Anúncio "Próxima palavra" ativado.' : 'Anúncio "Próxima palavra" desativado.'; 
        saveState();
      });
    })();

    // ensure buttons update when user returns to tab or focuses window
    window.addEventListener('visibilitychange', () => {
      if (!document.hidden) {
        // restore UI responsiveness
        updateButtonStates();
        updateAddWrongAvailability();
      }
    });
    window.addEventListener('focus', () => {
      updateButtonStates();
      updateAddWrongAvailability();
    });

    // initial state
    (function initialState(){
      showInactiveClock();
      hideMainTimerProxies();
      hideMainErrorProxies();
      setAutoArmedVisual(autoArmed);
      setErrorToggleVisual(errorMode);
      if (repeatBtn) { repeatBtn.disabled = !narratorEnabled; repeatBtn.title = narratorEnabled ? 'Repetir palavra (Seta ↑)' : 'Repetir desativado (Narrador desligado)'; }
      canShowRedo = false;
      if (totalCountDisplay) totalCountDisplay.textContent = `Carregadas: ${lastLoadedMain || 0}`;
      const restored = restoreStateIfAny();
      if (!restored) {
        canShowRedo = false;
        if (totalCountDisplay) totalCountDisplay.textContent = `Carregadas: ${lastLoadedMain || 0}`;
        updateWordCounter();
      }
      if (blurOn && currentWordEl) currentWordEl.classList.add('blurred');
      updateAddWrongAvailability();
      clearCopyIconTimersAndRestore();
      updateButtonStates();
    })();
  </script>
</body>
</html>
