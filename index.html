<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ditado — Opções (Timer / Erradas / Narrador)</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">

  <style>
    :root{ --muted:#6c757d; --accent:#10b981; --err:#dc2626; }
    body { background: linear-gradient(180deg,#f3f6fb,#ffffff); font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 18px; }
    .card { border-radius: 14px; box-shadow: 0 8px 30px rgba(17,24,39,0.06); }
    .btn { transition: transform .12s ease, box-shadow .12s ease; border-radius: 10px; -webkit-tap-highlight-color: rgba(0,0,0,0); }
    .btn:hover { transform: translateY(-3px); } .btn:active { transform: translateY(-1px) scale(.995); }
    .btn.touch-large { min-height:48px; padding-top:.6rem; padding-bottom:.6rem; }
    .btn-config.pulse { animation: pulse 1.6s infinite; box-shadow: 0 8px 32px rgba(16,185,129,0.12); }
    @keyframes pulse { 0%{transform:translateY(0)}50%{transform:translateY(-3px)}100%{transform:translateY(0)} }
    .btn-rotate { animation: rotatePulse 0.72s ease; } @keyframes rotatePulse { 0%{transform:rotate(0deg) scale(1)}40%{transform:rotate(200deg) scale(1.06)}100%{transform:rotate(360deg) scale(1)} }
    #currentWord{ font-weight:700; font-size:2.2rem; color:#0b2545; min-height:2.8rem; display:flex; align-items:center; justify-content:center; }
    #timerDisplay{ color:var(--muted); font-weight:600; }
    .chip{ border-radius:999px; padding:.35rem .75rem; margin:.25rem; display:inline-flex; align-items:center; gap:.5rem; background:#fff3f2; color:#7a0f0f; cursor:pointer; transition: transform .12s ease; }
    .chip:hover{ transform: translateY(-4px); background:#ffdede; }
    .countdown-wrap{ display:flex; align-items:center; gap:1rem; justify-content:center; margin-top:10px; position:relative; }
    .ring{ width:72px; height:72px; position:relative; } .ring svg{ transform: rotate(-90deg); width:100%; height:100%; display:block; }
    .ring .center-label{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-weight:700; color:#0b2545; font-size:0.95rem; }

    .inactive-clock { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:28px; color:#6c757d; pointer-events:none; transition: transform .45s cubic-bezier(.2,.9,.3,1), opacity .35s ease; }
    .inactive-clock.hidden { opacity:0; transform: scale(.92) rotate(-10deg); pointer-events:none; }
    .inactive-clock.visible { opacity:1; transform: scale(1) rotate(0deg); }

    .anim-to-ring { animation: clockToRing .52s ease forwards; }
    @keyframes clockToRing {
      0% { transform: scale(1) rotate(0deg); opacity:1; }
      40% { transform: scale(1.18) rotate(12deg); opacity:0.85; }
      100% { transform: scale(.9) rotate(40deg); opacity:0; }
    }

    .progress-transition { transition: stroke 420ms linear, stroke-dashoffset 240ms linear; }

    /* espaçamentos */
    .controls-top { margin-bottom: 18px; }
    .controls-bottom { margin-bottom: 18px; }
    #mainProxiesArea { margin: 18px 0; }

    @media (max-width:768px){
      .controls-top .col-auto{ width:100%; } .controls-top .btn{ width:100%; }
      .controls-bottom .col-auto{ width:100%; } .controls-bottom .btn{ width:100%; }
      .countdown-wrap{ flex-direction:column; gap:.5rem; } .ring{ width:86px; height:86px; } #currentWord{ font-size:1.6rem; }
      .keyboard-hint{ display:none !important; }
      .inactive-clock { font-size: 30px; } /* keep proportion on mobile */
    }
    @media (max-width:576px){ .ring{ width:64px; height:64px; } #currentWord{ font-size:1.4rem; } .inactive-clock { font-size:26px; } }
    .spaced-section{ margin-top:18px; margin-bottom:18px; }

    .proxy-btn { min-width: 120px; }
    .main-proxies { margin-bottom: 14px; display:flex; gap:.5rem; flex-wrap:wrap; justify-content:center; }
    .hidden { display:none !important; }

    /* help button — 30% menor (~26px) */
    .help-btn {
      width:26px; height:26px; border-radius:50%; padding:0; display:inline-flex; align-items:center; justify-content:center;
      background: linear-gradient(180deg,#0d6efd,#0069d9); color:white; border: none;
      box-shadow: 0 6px 16px rgba(13,110,253,0.18); font-weight:600; font-size:13px;
      transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease;
    }
    .help-btn:hover { transform: translateY(-3px) scale(1.03); box-shadow: 0 10px 22px rgba(13,110,253,0.22); opacity: .98; }
    .help-btn:active { transform: translateY(-1px) scale(.99); }

    .offcanvas .mb-3 h6 { margin-bottom: 6px; }

    /* pequeno espaçamento para o bloco de erradas sob o timer */
    #errorProxiesUnderTimer { margin-top: 12px; display:flex; gap:.5rem; justify-content:center; flex-wrap:wrap; }
  </style>
</head>
<body>
  <div class="container">
    <div class="card p-3 mx-auto" style="max-width:980px;">
      <div class="d-flex align-items-center justify-content-between mb-2">
        <h3 class="mb-0">Ditado de Palavras</h3>
        <div>
          <button id="configBtn" class="btn btn-outline-secondary btn-config pulse" data-bs-toggle="offcanvas" data-bs-target="#configOffcanvas" aria-controls="configOffcanvas" title="Opções">
            <i class="bi bi-gear-fill"></i> Opções
          </button>
        </div>
      </div>

      <!-- TOP: Carregar / Iniciar / Randomizar -->
      <div class="row g-2 mb-2 controls-top">
        <div class="col-auto">
          <button id="loadBtn" class="btn btn-primary btn-lg touch-large">
            <i class="bi bi-download me-2"></i>Carregar
          </button>
        </div>

        <div class="col-auto">
          <button id="startBtn" class="btn btn-success btn-lg touch-large" disabled>
            <i class="bi bi-play-fill me-2"></i>Iniciar
          </button>
        </div>

        <div class="col-auto">
          <button id="shuffleBtn" class="btn btn-outline-secondary btn-lg touch-large" disabled>
            <i class="bi bi-shuffle me-2"></i>Randomizar
          </button>
        </div>
      </div>

      <textarea id="wordList" class="form-control mb-3" rows="6" placeholder="Insira uma palavra por linha..."></textarea>

      <!-- BOTTOM: Voltar / Próxima / Repetir -->
      <div class="row g-2 mb-3 controls-bottom justify-content-center">
        <div class="col-auto">
          <button id="prevBtn" class="btn btn-outline-dark btn-lg touch-large" disabled>
            <i class="bi bi-skip-start-fill me-1"></i> Voltar
          </button>
        </div>

        <div class="col-auto">
          <button id="nextBtn" class="btn btn-outline-dark btn-lg touch-large" disabled>
            Próxima <i class="bi bi-skip-end-fill ms-1"></i>
          </button>
        </div>

        <div class="col-auto">
          <button id="repeatBtn" class="btn btn-outline-primary btn-lg btn-repeat touch-large" title="Repetir palavra (Seta ↑)">
            <i class="bi bi-arrow-repeat"></i> Repetir
          </button>
        </div>
      </div>

      <!-- Timer proxies (continuam aqui) -->
      <div id="mainProxiesArea" class="text-center mb-3">
        <div id="mainTimerProxies" class="main-proxies hidden" aria-hidden="true">
          <input id="intervalInputProxy" type="number" min="1" value="3" class="form-control" style="width:120px;">
          <button id="startTimerProxy" class="btn btn-success proxy-btn hidden">Iniciar Timer</button>
          <button id="pauseProxy" class="btn btn-warning proxy-btn hidden" title="Pausar (proxy)"><i class="bi bi-pause-fill me-1"></i> Pausar</button>
        </div>
      </div>

      <!-- Área central: palavra e contador (com ícone inativo) -->
      <div class="text-center mb-2 spaced-section">
        <div id="currentWord"></div>

        <div class="countdown-wrap" aria-hidden="false">
          <div class="ring" aria-hidden="true">
            <!-- SVG ring (progresso) -->
            <svg id="countdownSvg" viewBox="0 0 100 100" role="img" aria-label="Contador" style="display:block;">
              <circle cx="50" cy="50" r="44" stroke="#e6e6e6" stroke-width="10" fill="none"></circle>
              <circle id="progressCircle" cx="50" cy="50" r="44" stroke="#10b981" stroke-width="10" stroke-linecap="round" fill="none" stroke-dasharray="276.46" stroke-dashoffset="0" class="progress-transition"></circle>
            </svg>
            <!-- centro com segundos -->
            <div class="center-label" id="centerSeconds">-</div>
            <!-- ícone de relógio inativo (mostrado quando timer desativado) -->
            <div id="inactiveClock" class="inactive-clock visible" aria-hidden="true"><i class="bi bi-alarm"></i></div>
          </div>

          <div>
            <div id="timerDisplay" class="small"></div>
            <div id="status" class="text-muted small mt-1">Timer Desativado</div>
          </div>
        </div>

        <!-- *** bloco de botões de Ditado de Erradas agora posicionado AQUI, abaixo do timer *** -->
        <div id="errorProxiesUnderTimer" class="mt-2">
          <div id="mainErrorProxies" class="main-proxies hidden" aria-hidden="true">
            <button id="addWrongProxy" class="btn btn-outline-danger proxy-btn">Adicionar Errada</button>
            <button id="startErrorProxy" class="btn btn-danger proxy-btn">Ditado Erradas</button>
            <button id="launchErrorProxy" class="btn btn-success proxy-btn hidden">Iniciar Erradas</button>
            <button id="clearErrorProxy" class="btn btn-outline-danger proxy-btn">Limpar Erradas</button>
          </div>
        </div>
      </div>

      <div id="wrongSection" class="mt-3" style="display:none;">
        <h6 class="mb-2 text-danger">Palavras Erradas (clique para remover)</h6>
        <div id="wrongWordsList"></div>
      </div>

      <div id="errorListSection" class="mt-3" style="display:none;">
        <h6 class="mb-2 text-secondary">Revisão (lista original de erradas)</h6>
        <textarea id="errorListArea" class="form-control" rows="4" readonly></textarea>
      </div>

      <div class="mt-3 text-muted small keyboard-hint">
        Dica: use ← e → para navegar; pressione <span class="fw-bold">E</span> para marcar a palavra atual como errada (quando o registro estiver ativo). Pressione <span class="fw-bold">↑</span> para repetir a palavra.
      </div>
    </div>
  </div>

  <!-- Offcanvas / painel de OPÇÕES -->
  <div class="offcanvas offcanvas-end" tabindex="-1" id="configOffcanvas" aria-labelledby="configOffcanvasLabel">
    <div class="offcanvas-header">
      <h5 class="offcanvas-title" id="configOffcanvasLabel"><i class="bi bi-gear-fill me-2"></i>Opções</h5>
      <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Fechar"></button>
    </div>

    <div class="offcanvas-body">
      <!-- Timer (com ícone) -->
      <div class="mb-3 d-flex align-items-start justify-content-between">
        <div>
          <h6 class="mb-1"><i class="bi bi-clock-history me-2"></i>Timer</h6>
        </div>
        <button class="help-btn" data-bs-toggle="modal" data-bs-target="#helpTimerModal" title="Ajuda Timer">?</button>
      </div>
      <div class="d-flex align-items-center gap-2 mb-3">
        <button id="autoBtn" class="btn btn-outline-success btn-sm">Automático</button>
      </div>

      <hr>

      <!-- Ditado de Erradas (com ícone removido no botão) -->
      <div class="mb-3 d-flex align-items-start justify-content-between">
        <div>
          <h6 class="mb-1"><i class="bi bi-exclamation-triangle me-2"></i>Ditado de Erradas</h6>
        </div>
        <button class="help-btn" data-bs-toggle="modal" data-bs-target="#helpErradasModal" title="Ajuda Erradas">?</button>
      </div>
      <div class="d-flex gap-2 mb-3">
        <button id="toggleErrorBtn" class="btn btn-outline-danger btn-sm">Registrar Erradas (E)</button>
      </div>

      <hr>

      <!-- Narrador -->
      <div class="mb-3 d-flex align-items-start justify-content-between">
        <div>
          <h6 class="mb-1"><i class="bi bi-volume-up me-2"></i>Narrador</h6>
        </div>
        <button class="help-btn" data-bs-toggle="modal" data-bs-target="#helpNarradorModal" title="Ajuda Narrador">?</button>
      </div>

      <div class="d-flex flex-column gap-2 mb-2">
        <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" id="narratorToggle" checked>
          <label class="form-check-label" for="narratorToggle">Narrador (ativado)</label>
        </div>

        <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" id="announceNextToggle" checked>
          <label class="form-check-label" for="announceNextToggle">Falar "Próxima palavra" (ativado)</label>
        </div>

        <button id="unlockAudioBtn" class="btn btn-info btn-sm d-none" title="Destravar áudio"><i class="bi bi-volume-up me-1"></i> Tocar áudio (ativar voz)</button>
      </div>
    </div>
  </div>

  <!-- HELP MODALS -->
  <div class="modal fade" id="helpTimerModal" tabindex="-1" aria-labelledby="helpTimerModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="helpTimerModalLabel"><i class="bi bi-clock-history me-2"></i>Sobre o Timer</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
        </div>
        <div class="modal-body">
          <p>Ao ativar <strong>Automático</strong> aqui, os controles do timer aparecem na tela principal (intervalo e botão “Iniciar Timer”).</p>
          <ul>
            <li>É necessário primeiro iniciar o ditado com <strong>Iniciar</strong> (botão acima da lista). Depois, clique em <strong>Iniciar Timer</strong> para disparar o cronômetro automático.</li>
            <li>Se nenhuma palavra estiver carregada, o sistema solicitará que você carregue palavras antes do início.</li>
            <li>Use <em>Pausar</em> para interromper a contagem e <em>Retomar</em> para continuar (aparecerá apenas quando o timer tiver sido iniciado).</li>
          </ul>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="helpErradasModal" tabindex="-1" aria-labelledby="helpErradasModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="helpErradasModalLabel"><i class="bi bi-exclamation-triangle me-2"></i>Sobre Ditado de Erradas</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
        </div>
        <div class="modal-body">
          <p>Quando <strong>Registrar Erradas (E)</strong> está ativado, você pode marcar palavras que errar e revisá-las depois.</p>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="helpNarradorModal" tabindex="-1" aria-labelledby="helpNarradorModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="helpNarradorModalLabel"><i class="bi bi-volume-up me-2"></i>Sobre o Narrador</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
        </div>
        <div class="modal-body">
          <p>As opções do narrador permitem controlar a leitura das palavras e anúncios:</p>
          <ul>
            <li><strong>Narrador</strong>: ativa/desativa a leitura das palavras; também controla o botão Repetir.</li>
            <li><strong>Falar "Próxima palavra"</strong>: controla apenas a frase anunciada antes do avanço; se ativado, o anúncio será executado mesmo que o Narrador esteja desativado.</li>
          </ul>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" defer></script>

  <!-- SCRIPT: correção: controles de erradas só aparecem no fim se apropriado -->
  <script defer>
    // Elementos principais
    const loadBtn = document.getElementById('loadBtn');
    const startBtn = document.getElementById('startBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const repeatBtn = document.getElementById('repeatBtn');

    const autoBtn = document.getElementById('autoBtn');
    const toggleErrorBtn = document.getElementById('toggleErrorBtn');

    // proxies timer
    const startTimerProxy = document.getElementById('startTimerProxy');
    const pauseProxy = document.getElementById('pauseProxy');
    const intervalInputProxy = document.getElementById('intervalInputProxy');

    // proxies erradas (agora abaixo do timer)
    const addWrongProxy = document.getElementById('addWrongProxy');
    const startErrorProxy = document.getElementById('startErrorProxy');
    const launchErrorProxy = document.getElementById('launchErrorProxy');
    const clearErrorProxy = document.getElementById('clearErrorProxy');

    const inactiveClock = document.getElementById('inactiveClock');
    const progressCircle = document.getElementById('progressCircle');
    const centerSeconds = document.getElementById('centerSeconds');

    const narratorToggle = document.getElementById('narratorToggle');
    const announceNextToggle = document.getElementById('announceNextToggle');

    const wordListEl = document.getElementById('wordList');
    const currentWordEl = document.getElementById('currentWord');
    const timerDisplay = document.getElementById('timerDisplay');
    const statusEl = document.getElementById('status');
    const wrongSection = document.getElementById('wrongSection');
    const wrongWordsList = document.getElementById('wrongWordsList');
    const errorListSection = document.getElementById('errorListSection');
    const errorListArea = document.getElementById('errorListArea');

    // Estado
    let words = [];
    let wrongWords = [];
    let originalWrongWords = [];
    let index = 0;
    let errorMode = false;

    // timing
    let ringRaf = null;
    let ringStartTime = null;
    let ringDuration = null;
    let endTimer = null;
    let tickInterval = null;

    let remainingSec = 0;
    let isAuto = false;       // timer efetivamente rodando
    let isPaused = false;
    let awaitingAnnouncement = false;
    let pendingLaunch = false;
    let autoArmed = false;    // armado via menu (expor proxies)

    let dictationRunning = false; // indica se ditado já foi iniciado via botão Iniciar

    // narrator flags
    let narratorEnabled = true;     // só alterado pelo toggle do menu
    let announceNextEnabled = true;

    let audioUnlocked = false;

    const R = 44;
    const CIRC = 2 * Math.PI * R;
    progressCircle.style.strokeDasharray = `${CIRC}`;
    progressCircle.style.strokeDashoffset = `0`;

    const startColor = { r: 16, g: 185, b: 129 };
    const endColor = { r: 220, g: 38, b: 38 };

    function lerp(a,b,t){ return Math.round(a + (b-a)*t); }
    function colorLerp(c1,c2,t){ return `rgb(${lerp(c1.r,c2.r,t)}, ${lerp(c1.g,c2.g,t)}, ${lerp(c1.b,c2.b,t)})`; }

    function speakWithPromise(text, { interrupt = true, fallbackMs = 1200, allowWhenNarratorOff = false } = {}) {
      return new Promise((resolve) => {
        if (!narratorEnabled && !allowWhenNarratorOff) { resolve(); return; }
        try { if (interrupt) speechSynthesis.cancel(); } catch(e){}
        const u = new SpeechSynthesisUtterance(text);
        u.lang = 'pt-BR';
        let resolved = false;
        u.onend = () => { if (!resolved) { resolved = true; resolve(); } };
        u.onerror = () => { if (!resolved) { resolved = true; resolve(); } };
        const guard = setTimeout(() => { if (!resolved) { resolved = true; resolve(); } }, fallbackMs + 400);
        const originalResolve = resolve;
        resolve = () => { clearTimeout(guard); originalResolve(); };
        try { speechSynthesis.speak(u); } catch(e) { resolve(); }
      });
    }

    // Visual helpers
    function showInactiveClock() {
      inactiveClock.classList.remove('hidden');
      inactiveClock.classList.add('visible');
      document.getElementById('countdownSvg').style.display = 'none';
      centerSeconds.textContent = '-';
      progressCircle.style.strokeDashoffset = '0';
      progressCircle.style.stroke = colorLerp(startColor,endColor,0);
    }
    function hideInactiveClock() {
      inactiveClock.classList.remove('visible');
      inactiveClock.classList.add('hidden');
      document.getElementById('countdownSvg').style.display = 'block';
    }
    function animateClockToRingThenStart(callback) {
      inactiveClock.classList.remove('visible');
      inactiveClock.classList.remove('hidden');
      inactiveClock.classList.add('anim-to-ring');
      setTimeout(() => {
        inactiveClock.classList.add('hidden');
        inactiveClock.classList.remove('anim-to-ring');
        document.getElementById('countdownSvg').style.display = 'block';
        progressCircle.style.stroke = colorLerp(startColor, endColor, 0);
        progressCircle.classList.add('progress-transition');
        if (typeof callback === 'function') callback();
      }, 520);
    }

    function setAutoArmedVisual(on){
      if(on){ autoBtn.classList.remove('btn-outline-success'); autoBtn.classList.add('btn-success','pulse'); }
      else { autoBtn.classList.remove('btn-success','pulse'); autoBtn.classList.add('btn-outline-success'); }
      if(on) showMainTimerProxies(); else hideMainTimerProxies();
      if(!on) statusEl.textContent = 'Timer Desativado'; else statusEl.textContent = 'Timer Pronto';
    }
    function setAutoRunningVisual(on){
      if(on){ autoBtn.classList.remove('btn-outline-success'); autoBtn.classList.add('btn-success','pulse'); }
      else { autoBtn.classList.remove('btn-success','pulse'); autoBtn.classList.add('btn-outline-success'); }
    }
    function setPauseVisual(paused){
      if(paused){ pauseProxy.classList.remove('btn-outline-warning'); pauseProxy.classList.add('btn-warning','active'); pauseProxy.innerHTML = '<i class="bi bi-play-fill me-1"></i> Retomar'; }
      else { pauseProxy.classList.remove('btn-warning','active'); pauseProxy.classList.add('btn-outline-warning'); pauseProxy.innerHTML = '<i class="bi bi-pause-fill me-1"></i> Pausar'; }
    }

    // botão de registro — sem ícone (mantive sua lógica anterior)
    function setErrorToggleVisual(on){
      if(on){ toggleErrorBtn.classList.remove('btn-outline-danger'); toggleErrorBtn.classList.add('btn-danger','btn-err-active'); toggleErrorBtn.textContent = 'Registro Ativo'; }
      else { toggleErrorBtn.classList.remove('btn-danger','btn-err-active'); toggleErrorBtn.classList.add('btn-outline-danger'); toggleErrorBtn.textContent = 'Registrar Erradas (E)'; }
      if(on) showMainErrorProxies(); else hideMainErrorProxies();
    }

    // countdown
    function clearCountdown(){
      if(endTimer){ clearTimeout(endTimer); endTimer=null; }
      if(tickInterval){ clearInterval(tickInterval); tickInterval=null; }
      if(ringRaf){ cancelAnimationFrame(ringRaf); ringRaf=null; }
      ringStartTime=null; ringDuration=null;
      progressCircle.style.transition = 'stroke-dashoffset 240ms linear, stroke 240ms linear';
      progressCircle.style.strokeDashoffset = '0';
      progressCircle.style.stroke = colorLerp(startColor, endColor, 0);
      centerSeconds.textContent='-';
      timerDisplay.textContent='';
    }

    function setCountdownFor(sec){
      if(pendingLaunch){ clearCountdown(); return; }
      clearCountdown();
      remainingSec = Math.max(1, Math.floor(sec) || 1);
      ringDuration = remainingSec * 1000;
      ringStartTime = performance.now();
      progressCircle.style.transition='none';
      progressCircle.style.stroke = colorLerp(startColor, endColor, 0);
      updateCenterSeconds(remainingSec);
      timerDisplay.textContent = `Próxima em: ${remainingSec}s`;
      endTimer = setTimeout(()=>{ clearCountdown(); announceThenAdvance(); }, ringDuration);
      tickInterval = setInterval(()=>{
        if(isPaused) return;
        const elapsedMs = performance.now() - ringStartTime;
        const remMs = Math.max(0, ringDuration - elapsedMs);
        const rem = Math.ceil(remMs / 1000);
        updateCenterSeconds(rem);
        timerDisplay.textContent = `Próxima em: ${rem}s`;
      },150);
      function step(now){
        if(!ringStartTime || isPaused){ ringRaf = requestAnimationFrame(step); return; }
        const elapsedMs = now - ringStartTime;
        const progress = Math.min(1, elapsedMs / ringDuration);
        const offset = progress * CIRC;
        progressCircle.style.strokeDashoffset = `${offset}`;
        progressCircle.style.stroke = colorLerp(startColor, endColor, progress);
        if(progress < 1) ringRaf = requestAnimationFrame(step);
        else { progressCircle.style.strokeDashoffset = `${CIRC}`; progressCircle.style.stroke = colorLerp(startColor,endColor,1); }
      }
      ringRaf = requestAnimationFrame(step);
    }

    function updateCenterSeconds(n){ centerSeconds.textContent = `${n}s`; }

    function speakAndShow(text){
      currentWordEl.textContent = text;
      if (!narratorEnabled) return;
      try { speechSynthesis.cancel(); } catch(e){}
      const u = new SpeechSynthesisUtterance(text); u.lang = 'pt-BR';
      speechSynthesis.speak(u);
    }

    async function announceThenAdvance(){
      if(awaitingAnnouncement) return;
      if(pendingLaunch){ awaitingAnnouncement=false; return; }
      awaitingAnnouncement = true;
      try {
        try{ speechSynthesis.cancel(); } catch(e){}
        if (announceNextEnabled) {
          await speakWithPromise('Próxima palavra', { interrupt:true, fallbackMs:900, allowWhenNarratorOff:true });
        }
      } catch(e){}
      finally {
        awaitingAnnouncement = false;
        if(!isPaused && !pendingLaunch) advanceDictation();
        else timerDisplay.textContent='';
      }
    }

    // dictation flow
    function beginDictation(){
      dictationRunning = true; index = 0; awaitingAnnouncement = false;
      speakAndShow(words[index]);
      nextBtn.disabled = false; startBtn.disabled = true;
      // garantir pause oculto no início do ditado
      isPaused = false;
      setPauseVisual(false);
      pauseProxy.classList.add('hidden');
      if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
    }

    function advanceDictation(fromManual=false){
      index++;
      if(index < words.length){
        speakAndShow(words[index]);
        prevBtn.disabled = false;
        if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
      } else finishDictation();
    }

    function finishDictation(){
      dictationRunning = false;
      clearCountdown();
      alert('Ditado concluído!');
      currentWordEl.textContent=''; nextBtn.disabled=true; prevBtn.disabled=true; startBtn.disabled=false; shuffleBtn.disabled=false;
      autoBtn.classList.remove('btn-success','pulse'); autoBtn.classList.add('btn-outline-success');
      statusEl.textContent = `Concluído. Erros dinâmicos: ${wrongWords.length}`;
      isAuto = false; isPaused = false; pendingLaunch = false;
      if (autoArmed) showStartTimerProxy(); else hideMainTimerProxies();

      // === CORREÇÃO AQUI: só mostrar controles de erradas se o usuário tiver
      // o recurso ativado em Opções (errorMode) OU já existir palavras marcadas.
      if (errorMode || (wrongWords && wrongWords.length > 0) || (originalWrongWords && originalWrongWords.length > 0)) {
        showMainErrorProxies();
      } else {
        hideMainErrorProxies();
      }

      // manter o ícone inativo do clock
      showInactiveClock();
    }

    function pauseAuto(){
      if(!isAuto || isPaused) return;
      isPaused = true;
      if(ringStartTime && ringDuration){
        const elapsedMs = performance.now() - ringStartTime;
        const remMs = Math.max(0, ringDuration - elapsedMs);
        remainingSec = Math.max(0, Math.ceil(remMs / 1000));
      } else remainingSec = Math.max(1, remainingSec || 1);
      clearCountdown();
      try { speechSynthesis.cancel(); } catch(e){}
      awaitingAnnouncement = false;
      statusEl.textContent = `Automático pausado. ${remainingSec}s restantes.`;
      setPauseVisual(true);
    }

    function resumeAuto(){
      if(!isAuto || !isPaused) return;
      isPaused = false;
      setPauseVisual(false);
      statusEl.textContent = 'Automático retomado.';
      try { speechSynthesis.cancel(); } catch(e){}
      speakAndShow(words[index]);
      const secToUse = Math.max(1, remainingSec || 1);
      if(!pendingLaunch) setCountdownFor(secToUse); else clearCountdown();
    }

    // proxies visibility (com mutual-exclusion reforçada entre startTimerProxy e pauseProxy)
    function showMainTimerProxies(){
      const area = document.getElementById('mainTimerProxies');
      area.classList.remove('hidden'); area.setAttribute('aria-hidden','false');
      // mostrar startTimer e garantir pause escondido (não podem coexistir)
      showStartTimerProxy();
    }
    function hideMainTimerProxies(){
      const area = document.getElementById('mainTimerProxies');
      area.classList.add('hidden'); area.setAttribute('aria-hidden','true');
      startTimerProxy.classList.add('hidden');
      pauseProxy.classList.add('hidden');
    }
    function showStartTimerProxy(){
      startTimerProxy.classList.remove('hidden');
      // quando o botão "Iniciar Timer" está visível, o botão Pausar deve ficar oculto para evitar erros
      pauseProxy.classList.add('hidden');
    }
    function hideStartTimerProxy(){
      startTimerProxy.classList.add('hidden');
      // quando removemos o botão "Iniciar Timer" (ou seja, o timer foi iniciado), mostramos o botão Pausar
      if(isAuto) pauseProxy.classList.remove('hidden'); else pauseProxy.classList.add('hidden');
    }

    function showMainErrorProxies(){
      const area = document.getElementById('mainErrorProxies');
      area.classList.remove('hidden'); area.setAttribute('aria-hidden','false');
      addWrongProxy.classList.remove('hidden'); startErrorProxy.classList.remove('hidden'); clearErrorProxy.classList.remove('hidden');
      if(pendingLaunch) launchErrorProxy.classList.remove('hidden'); else launchErrorProxy.classList.add('hidden');
    }
    function hideMainErrorProxies(){
      const area = document.getElementById('mainErrorProxies');
      area.classList.add('hidden'); area.setAttribute('aria-hidden','true');
      addWrongProxy.classList.add('hidden'); startErrorProxy.classList.add('hidden'); launchErrorProxy.classList.add('hidden'); clearErrorProxy.classList.add('hidden');
    }

    function renderWrongWords(){
      wrongWordsList.innerHTML = wrongWords.map(w => `<span class="chip" role="button" tabindex="0">${w} <i class="bi bi-x-lg ms-1"></i></span>`).join('');
      startErrorProxy.disabled = wrongWords.length === 0;
      clearErrorProxy.disabled = wrongWords.length === 0;
      wrongSection.style.display = (wrongWords.length>0 || errorMode) ? 'block' : 'none';
    }

    // eventos
    autoBtn.addEventListener('click', () => {
      autoArmed = !autoArmed;
      setAutoArmedVisual(autoArmed);
      if (autoArmed) {
        statusEl.textContent = 'Timer Pronto';
        showInactiveClock();
      } else {
        statusEl.textContent = 'Timer Desativado';
        if (isAuto) { isAuto=false; isPaused=false; clearCountdown(); }
        showInactiveClock();
      }
    });

    // iniciar timer: exige ditado iniciado; ao iniciar, ocultamos startTimerProxy e exibimos pauseProxy
    startTimerProxy.addEventListener('click', () => {
      if (!autoArmed) { statusEl.textContent = 'Ative Automático no menu de Opções primeiro.'; return; }
      if (!words || words.length === 0) { statusEl.textContent = 'Carregue palavras antes de iniciar o timer.'; return; }
      if (!dictationRunning) { statusEl.textContent = 'Inicie o ditado (botão "Iniciar") antes de ativar o timer.'; return; }

      isAuto = true; isPaused = false;
      setAutoRunningVisual(true);
      statusEl.textContent = 'Timer iniciado.';
      // oculta startTimer e mostra pause (mutual-exclusion)
      hideStartTimerProxy();
      pauseProxy.classList.remove('hidden');

      animateClockToRingThenStart(() => {
        setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
      });
    });

    pauseProxy.addEventListener('click', () => { if(!isAuto) return; if(isPaused) resumeAuto(); else pauseAuto(); });

    intervalInputProxy.addEventListener('change', (e) => { if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10))); });

    addWrongProxy.addEventListener('click', () => { if(!errorMode || !currentWordEl.textContent) return; const w = currentWordEl.textContent; if(!wrongWords.includes(w)){ wrongWords.push(w); statusEl.textContent = `"${w}" adicionada às erradas.`; renderWrongWords(); } });

    startErrorProxy.addEventListener('click', () => { if(!wrongWords.length) return; originalWrongWords = [...wrongWords]; words = [...originalWrongWords]; index = 0; statusEl.textContent = 'Preparado: pronto para iniciar revisão das erradas.'; pendingLaunch = true; try{ speechSynthesis.cancel(); }catch(e){} clearCountdown(); awaitingAnnouncement = false; launchErrorProxy.classList.remove('hidden'); renderWrongWords(); });

    launchErrorProxy.addEventListener('click', () => { launchErrorProxy.classList.add('hidden'); index = 0; statusEl.textContent = 'Ditado de erradas iniciado.'; pendingLaunch = false; prevBtn.disabled = false; errorListSection.style.display = 'block'; errorListArea.value = originalWrongWords.join('\n'); wrongWords = []; renderWrongWords(); beginDictation(); if(isAuto && !isPaused){ awaitingAnnouncement=false; setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10))); } });

    clearErrorProxy.addEventListener('click', () => { wrongWords = []; originalWrongWords = []; renderWrongWords(); errorListSection.style.display = 'none'; wrongSection.style.display = 'none'; pendingLaunch = false; launchErrorProxy.classList.add('hidden'); hideMainErrorProxies(); });

    // --- ao carregar lista: resetamos estado de pause e garantimos pause oculto ---
    loadBtn.addEventListener('click', () => {
      const raw = wordListEl.value.trim();
      if(!raw) return alert('Insira ao menos uma palavra.');
      words = raw.split(/\r?\n/).map(w=>w.trim()).filter(Boolean);
      index = 0; isAuto = false; isPaused = false; wrongWords=[]; originalWrongWords=[];
      startBtn.disabled = false; shuffleBtn.disabled = false; prevBtn.disabled = true; nextBtn.disabled = true;
      currentWordEl.textContent=''; clearCountdown();
      statusEl.textContent = `Lista carregada: ${words.length} palavras.`;
      wrongSection.style.display='none'; errorListSection.style.display='none'; renderWrongWords();
      pendingLaunch = false;
      // reset visual do pause (ocultar)
      setPauseVisual(false); pauseProxy.classList.add('hidden');
      if (autoArmed) { showStartTimerProxy(); showInactiveClock(); } else { hideMainTimerProxies(); showInactiveClock(); }
      if (errorMode) showMainErrorProxies(); else hideMainErrorProxies();
    });

    shuffleBtn.addEventListener('click', () => { for (let i = words.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [words[i], words[j]] = [words[j], words[i]]; } index = 0; statusEl.textContent = 'Lista embaralhada.'; renderWrongWords(); });

    // --- ao iniciar o ditado: garantir pause oculto (aparece só quando o timer iniciar) ---
    startBtn.addEventListener('click', () => {
      if(!words.length) return;
      wrongSection.style.display='none'; errorListSection.style.display='none';
      beginDictation();
      shuffleBtn.disabled=true; prevBtn.disabled=false;
      setPauseVisual(false); pauseProxy.classList.add('hidden');
      if(autoArmed) showStartTimerProxy();
    });

    toggleErrorBtn.addEventListener('click', () => {
      errorMode = !errorMode;
      setErrorToggleVisual(errorMode);
      statusEl.textContent = errorMode ? 'Registro de erros ativado.' : 'Registro de erros desativado.';
    });

    prevBtn.addEventListener('click', () => { if(index > 0){ index--; speakAndShow(words[index]); nextBtn.disabled=false; if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10))); } if(index === 0) prevBtn.disabled = true; });

    nextBtn.addEventListener('click', () => { clearCountdown(); advanceDictation(true); });

    repeatBtn.addEventListener('click', () => { if(!words.length || !currentWordEl.textContent) return; if (narratorEnabled) { repeatBtn.classList.add('btn-rotate'); try{ speechSynthesis.cancel(); }catch(e){} const u=new SpeechSynthesisUtterance(words[index]); u.lang='pt-BR'; u.onend=()=>{ repeatBtn.classList.remove('btn-rotate'); }; speechSynthesis.speak(u); setTimeout(()=>repeatBtn.classList.remove('btn-rotate'),1200); } });

    document.addEventListener('keydown', (e) => { const active = document.activeElement && document.activeElement.tagName ? document.activeElement.tagName.toLowerCase() : ''; if(active === 'input' || active === 'textarea') return; if(e.key === 'ArrowUp'){ e.preventDefault(); if(!repeatBtn.disabled) repeatBtn.click(); return; } if(errorMode && e.key.toLowerCase() === 'e' && currentWordEl.textContent){ const w = currentWordEl.textContent; if(!wrongWords.includes(w)){ wrongWords.push(w); statusEl.textContent = `"${w}" adicionada às erradas.`; renderWrongWords(); } } if(e.key === 'ArrowRight'){ e.preventDefault(); if(!nextBtn.disabled) nextBtn.click(); } else if(e.key === 'ArrowLeft'){ e.preventDefault(); if(!prevBtn.disabled) prevBtn.click(); } });

    wrongWordsList.addEventListener('click', (e) => { let target=e.target; while(target && !target.classList.contains('chip')) target=target.parentElement; if(!target) return; const txt=target.textContent.trim(); const w=txt.replace(/\s*×\s*$/,'').trim(); const idx=wrongWords.indexOf(w); if(idx>=0) wrongWords.splice(idx,1); renderWrongWords(); });

    // unlock audio for touch
    const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    const unlockAudioBtn = document.getElementById('unlockAudioBtn');
    if(unlockAudioBtn && isTouchDevice){
      unlockAudioBtn.classList.remove('d-none');
      unlockAudioBtn.addEventListener('click', async () => {
        try { if (narratorEnabled) await speakWithPromise('Áudio ativado', { interrupt:true, fallbackMs:700, allowWhenNarratorOff:true }); audioUnlocked=true; statusEl.textContent='Áudio ativado para este dispositivo.'; } catch(e){ statusEl.textContent='Não foi possível ativar áudio automaticamente.'; } finally { unlockAudioBtn.classList.add('d-none'); }
      });
    }

    // narrator toggles (apenas aqui alteram narratorEnabled)
    narratorToggle.addEventListener('change', () => {
      narratorEnabled = !!narratorToggle.checked;
      narratorToggle.nextElementSibling.textContent = narratorEnabled ? 'Narrador (ativado)' : 'Narrador (desativado)';
      statusEl.textContent = narratorEnabled ? 'Narrador ativado.' : 'Narrador desativado.';
      // controlar botão repetir junto ao narrador
      repeatBtn.disabled = !narratorEnabled;
      repeatBtn.title = narratorEnabled ? 'Repetir palavra (Seta ↑)' : 'Repetir desativado (Narrador desligado)';
    });

    announceNextToggle.addEventListener('change', () => {
      announceNextEnabled = !!announceNextToggle.checked;
      announceNextToggle.nextElementSibling.textContent = announceNextEnabled ? 'Falar "Próxima palavra" (ativado)' : 'Falar "Próxima palavra" (desativado)';
      statusEl.textContent = announceNextEnabled ? 'Anúncio "Próxima palavra" ativado.' : 'Anúncio "Próxima palavra" desativado.';
    });

    // initial state
    (function initialState(){
      showInactiveClock();
      hideMainTimerProxies();
      hideMainErrorProxies();
      setAutoArmedVisual(autoArmed);
      setErrorToggleVisual(errorMode);
      repeatBtn.disabled = !narratorEnabled;
      repeatBtn.title = narratorEnabled ? 'Repetir palavra (Seta ↑)' : 'Repetir desativado (Narrador desligado)';
    })();

    function hideMainTimerProxies(){ const area = document.getElementById('mainTimerProxies'); area.classList.add('hidden'); area.setAttribute('aria-hidden','true'); startTimerProxy.classList.add('hidden'); pauseProxy.classList.add('hidden'); }
    function hideMainErrorProxies(){ const area = document.getElementById('mainErrorProxies'); area.classList.add('hidden'); area.setAttribute('aria-hidden','true'); addWrongProxy.classList.add('hidden'); startErrorProxy.classList.add('hidden'); launchErrorProxy.classList.add('hidden'); clearErrorProxy.classList.add('hidden'); }

  </script>
</body>
</html>
