<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ditado — Config Menu (Auto / Erradas) — Atualizado</title>

  <!-- Bootstrap CSS (CDN) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">

  <style>
    :root{ --muted:#6c757d; --accent:#10b981; --err:#dc2626; }
    body { background: linear-gradient(180deg,#f3f6fb,#ffffff); font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 18px; }
    .card { border-radius: 14px; box-shadow: 0 8px 30px rgba(17,24,39,0.06); }
    .btn { transition: transform .12s ease, box-shadow .12s ease; border-radius: 10px; -webkit-tap-highlight-color: rgba(0,0,0,0); }
    .btn:hover { transform: translateY(-3px); } .btn:active { transform: translateY(-1px) scale(.995); }
    .btn.touch-large { min-height:48px; padding-top:.6rem; padding-bottom:.6rem; }
    .btn-config.pulse { animation: pulse 1.6s infinite; box-shadow: 0 8px 32px rgba(16,185,129,0.12); }
    @keyframes pulse { 0%{transform:translateY(0)}50%{transform:translateY(-3px)}100%{transform:translateY(0)} }
    .btn-rotate { animation: rotatePulse 0.72s ease; } @keyframes rotatePulse { 0%{transform:rotate(0deg) scale(1)}40%{transform:rotate(200deg) scale(1.06)}100%{transform:rotate(360deg) scale(1)} }
    #currentWord{ font-weight:700; font-size:2.2rem; color:#0b2545; min-height:2.8rem; display:flex; align-items:center; justify-content:center; }
    #timerDisplay{ color:var(--muted); font-weight:600; }
    .chip{ border-radius:999px; padding:.35rem .75rem; margin:.25rem; display:inline-flex; align-items:center; gap:.5rem; background:#fff3f2; color:#7a0f0f; cursor:pointer; transition: transform .12s ease; }
    .chip:hover{ transform: translateY(-4px); background:#ffdede; }
    .countdown-wrap{ display:flex; align-items:center; gap:1rem; justify-content:center; margin-top:10px; }
    .ring{ width:72px; height:72px; position:relative; } .ring svg{ transform: rotate(-90deg); width:100%; height:100%; }
    .ring .center-label{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-weight:700; color:#0b2545; font-size:0.95rem; }

    /* --- espaçamento entre grupos: ajustado para evitar "bagunça" --- */
    .controls-top { margin-bottom: 18px; }
    .controls-bottom { margin-bottom: 18px; }
    #mainProxiesArea { margin: 18px 0; }

    @media (max-width:768px){
      .controls-top .col-auto{ width:100%; } .controls-top .btn{ width:100%; }
      .controls-bottom .col-auto{ width:100%; } .controls-bottom .btn{ width:100%; }
      .countdown-wrap{ flex-direction:column; gap:.5rem; } .ring{ width:86px; height:86px; } #currentWord{ font-size:1.6rem; }
      .keyboard-hint{ display:none !important; }
    }
    @media (max-width:576px){ .ring{ width:64px; height:64px; } #currentWord{ font-size:1.4rem; } }
    .spaced-section{ margin-top:18px; margin-bottom:18px; }

    .proxy-btn { min-width: 120px; }
    .main-proxies { margin-bottom: 14px; display:flex; gap:.5rem; flex-wrap:wrap; justify-content:center; }
    .hidden { display:none !important; }
  </style>
</head>
<body>
  <div class="container">
    <div class="card p-3 mx-auto" style="max-width:980px;">
      <div class="d-flex align-items-center justify-content-between mb-2">
        <h3 class="mb-0">Ditado de Palavras</h3>
        <div>
          <button id="configBtn" class="btn btn-outline-secondary btn-config pulse" data-bs-toggle="offcanvas" data-bs-target="#configOffcanvas" aria-controls="configOffcanvas" title="Configurações">
            <i class="bi bi-gear-fill"></i> Configurações
          </button>
        </div>
      </div>

      <!-- TOP: Carregar / Iniciar / Randomizar (acima da tabela) -->
      <div class="row g-2 mb-2 controls-top">
        <div class="col-auto">
          <button id="loadBtn" class="btn btn-primary btn-lg touch-large">
            <i class="bi bi-download me-2"></i>Carregar
          </button>
        </div>

        <div class="col-auto">
          <button id="startBtn" class="btn btn-success btn-lg touch-large" disabled>
            <i class="bi bi-play-fill me-2"></i>Iniciar
          </button>
        </div>

        <div class="col-auto">
          <button id="shuffleBtn" class="btn btn-outline-secondary btn-lg touch-large" disabled>
            <i class="bi bi-shuffle me-2"></i>Randomizar
          </button>
        </div>
      </div>

      <textarea id="wordList" class="form-control mb-3" rows="6" placeholder="Insira uma palavra por linha..."></textarea>

      <!-- BOTTOM (embaixo da tabela): Voltar / Próxima / Repetir -->
      <div class="row g-2 mb-3 controls-bottom justify-content-center">
        <div class="col-auto">
          <button id="prevBtn" class="btn btn-outline-dark btn-lg touch-large" disabled>
            <i class="bi bi-skip-start-fill me-1"></i> Voltar
          </button>
        </div>

        <div class="col-auto">
          <button id="nextBtn" class="btn btn-outline-dark btn-lg touch-large" disabled>
            Próxima <i class="bi bi-skip-end-fill ms-1"></i>
          </button>
        </div>

        <div class="col-auto">
          <button id="repeatBtn" class="btn btn-outline-primary btn-lg btn-repeat touch-large" title="Repetir palavra (Seta ↑)">
            <i class="bi bi-arrow-repeat"></i> Repetir
          </button>
        </div>
      </div>

      <!-- Proxies principais (aparecem somente quando ativados no menu) -->
      <div id="mainProxiesArea" class="text-center mb-3">
        <div id="mainTimerProxies" class="main-proxies hidden" aria-hidden="true">
          <input id="intervalInputProxy" type="number" min="1" value="3" class="form-control" style="width:120px;">
          <button id="autoProxy" class="btn btn-success proxy-btn hidden" title="Automático (proxy)"><i class="bi bi-clock-history me-1"></i> Automático</button>
          <button id="pauseProxy" class="btn btn-warning proxy-btn hidden" title="Pausar (proxy)"><i class="bi bi-pause-fill me-1"></i> Pausar</button>
        </div>

        <div id="mainErrorProxies" class="main-proxies hidden" aria-hidden="true">
          <button id="addWrongProxy" class="btn btn-outline-danger proxy-btn">Adicionar Errada</button>
          <button id="startErrorProxy" class="btn btn-danger proxy-btn">Ditado Erradas</button>
          <button id="launchErrorProxy" class="btn btn-success proxy-btn hidden">Iniciar Erradas</button>
          <button id="clearErrorProxy" class="btn btn-outline-danger proxy-btn">Limpar Erradas</button>
        </div>
      </div>

      <div class="text-center mb-2 spaced-section">
        <div id="currentWord"></div>

        <div class="countdown-wrap">
          <div class="ring" aria-hidden="true">
            <svg id="countdownSvg" viewBox="0 0 100 100" role="img" aria-label="Contador">
              <circle cx="50" cy="50" r="44" stroke="#e6e6e6" stroke-width="10" fill="none"></circle>
              <circle id="progressCircle" cx="50" cy="50" r="44" stroke="#10b981" stroke-width="10" stroke-linecap="round" fill="none" stroke-dasharray="276.46" stroke-dashoffset="0"></circle>
            </svg>
            <div class="center-label" id="centerSeconds">-</div>
          </div>

          <div>
            <div id="timerDisplay" class="small"></div>
            <div id="status" class="text-muted small mt-1"></div>
          </div>
        </div>
      </div>

      <div id="wrongSection" class="mt-3" style="display:none;">
        <h6 class="mb-2 text-danger">Palavras Erradas (clique para remover)</h6>
        <div id="wrongWordsList"></div>
      </div>

      <div id="errorListSection" class="mt-3" style="display:none;">
        <h6 class="mb-2 text-secondary">Revisão (lista original de erradas)</h6>
        <textarea id="errorListArea" class="form-control" rows="4" readonly></textarea>
      </div>

      <div class="mt-3 text-muted small keyboard-hint">
        Dica: use ← e → para navegar; pressione <span class="fw-bold">E</span> para marcar a palavra atual como errada (quando o registro estiver ativo). Pressione <span class="fw-bold">↑</span> para repetir a palavra.
      </div>
    </div>
  </div>

  <!-- Offcanvas com apenas Automático e Registrar Erradas -->
  <div class="offcanvas offcanvas-end" tabindex="-1" id="configOffcanvas" aria-labelledby="configOffcanvasLabel">
    <div class="offcanvas-header">
      <h5 class="offcanvas-title" id="configOffcanvasLabel"><i class="bi bi-gear-fill me-2"></i>Configurações</h5>
      <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Fechar"></button>
    </div>
    <div class="offcanvas-body">
      <div class="mb-3">
        <h6><i class="bi bi-clock-history me-2"></i>Timer</h6>
        <div class="d-flex align-items-center gap-2 mb-2">
          <button id="autoBtn" class="btn btn-outline-success btn-sm"><i class="bi bi-clock-history me-1"></i> Automático</button>
        </div>
        <div class="small text-muted">Ative aqui para expor os controles do timer na tela principal.</div>
      </div>

      <hr>

      <div class="mb-3">
        <h6><i class="bi bi-exclamation-triangle me-2"></i>Ditado de Erradas</h6>
        <div class="d-flex gap-2 mb-2">
          <button id="toggleErrorBtn" class="btn btn-outline-danger btn-sm"><i class="bi bi-exclamation-triangle me-1"></i> Registrar Erradas (E)</button>
        </div>
        <div class="small text-muted">Ative aqui para expor os controles de erradas na tela principal.</div>
      </div>

      <hr>

      <div class="mb-3">
        <h6><i class="bi bi-volume-up me-2"></i>Áudio</h6>
        <div class="d-flex gap-2">
          <button id="unlockAudioBtn" class="btn btn-info btn-sm d-none"><i class="bi bi-volume-up me-1"></i> Tocar áudio (ativar voz)</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" defer></script>

  <!-- Script mantido com correção do pauseProxy e alguns ajustes de espaçamento -->
  <script defer>
    /* === elementos principais (masters + proxies) === */
    const loadBtn = document.getElementById('loadBtn');
    const startBtn = document.getElementById('startBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const repeatBtn = document.getElementById('repeatBtn');

    const autoBtn = document.getElementById('autoBtn');           // master no offcanvas
    const toggleErrorBtn = document.getElementById('toggleErrorBtn'); // master no offcanvas
    const unlockAudioBtn = document.getElementById('unlockAudioBtn');

    const autoProxy = document.getElementById('autoProxy');
    const pauseProxy = document.getElementById('pauseProxy');
    const intervalInputProxy = document.getElementById('intervalInputProxy');

    const addWrongProxy = document.getElementById('addWrongProxy');
    const startErrorProxy = document.getElementById('startErrorProxy');
    const launchErrorProxy = document.getElementById('launchErrorProxy');
    const clearErrorProxy = document.getElementById('clearErrorProxy');

    const wordListEl = document.getElementById('wordList');
    const currentWordEl = document.getElementById('currentWord');
    const timerDisplay = document.getElementById('timerDisplay');
    const statusEl = document.getElementById('status');
    const wrongSection = document.getElementById('wrongSection');
    const wrongWordsList = document.getElementById('wrongWordsList');
    const errorListSection = document.getElementById('errorListSection');
    const errorListArea = document.getElementById('errorListArea');
    const progressCircle = document.getElementById('progressCircle');
    const centerSeconds = document.getElementById('centerSeconds');

    /* === estados e funções (mantidos) === */
    let words = [];
    let wrongWords = [];
    let originalWrongWords = [];
    let index = 0;
    let errorMode = false;

    let ringRaf = null;
    let ringStartTime = null;
    let ringDuration = null;
    let endTimer = null;
    let tickInterval = null;

    let remainingSec = 0;
    let isAuto = false;
    let isPaused = false;
    let awaitingAnnouncement = false;
    let pendingLaunch = false;
    let audioUnlocked = false;

    const R = 44;
    const CIRC = 2 * Math.PI * R;
    progressCircle.style.strokeDasharray = `${CIRC}`;
    progressCircle.style.strokeDashoffset = `0`;

    const startColor = { r: 16, g: 185, b: 129 };
    const endColor = { r: 220, g: 38, b: 38 };

    function lerp(a,b,t){ return Math.round(a + (b-a)*t); }
    function colorLerp(c1,c2,t){ return `rgb(${lerp(c1.r,c2.r,t)}, ${lerp(c1.g,c2.g,t)}, ${lerp(c1.b,c2.b,t)})`; }

    function speakWithPromise(text, { interrupt=true, fallbackMs=1200 }={}) {
      return new Promise((resolve) => {
        try { if (interrupt) speechSynthesis.cancel(); } catch(e){}
        const u = new SpeechSynthesisUtterance(text); u.lang='pt-BR';
        let resolved=false;
        u.onend = () => { if(!resolved){ resolved=true; resolve(); } };
        u.onerror = () => { if(!resolved){ resolved=true; resolve(); } };
        const guard = setTimeout(()=>{ if(!resolved){ resolved=true; resolve(); } }, fallbackMs+400);
        const originalResolve = resolve;
        resolve = () => { clearTimeout(guard); originalResolve(); };
        try { speechSynthesis.speak(u); } catch(e){ resolve(); }
      });
    }

    function clearCountdown(){
      if(endTimer){ clearTimeout(endTimer); endTimer=null; }
      if(tickInterval){ clearInterval(tickInterval); tickInterval=null; }
      if(ringRaf){ cancelAnimationFrame(ringRaf); ringRaf=null; }
      ringStartTime=null; ringDuration=null;
      progressCircle.style.transition = 'stroke-dashoffset 240ms linear, stroke 240ms linear';
      progressCircle.style.strokeDashoffset = '0';
      progressCircle.style.stroke = colorLerp(startColor, endColor, 0);
      centerSeconds.textContent='-';
      timerDisplay.textContent='';
    }

    function setCountdownFor(sec){
      if(pendingLaunch){ clearCountdown(); return; }
      clearCountdown();
      remainingSec = Math.max(1, Math.floor(sec) || 1);
      ringDuration = remainingSec * 1000;
      ringStartTime = performance.now();
      progressCircle.style.transition='none';
      progressCircle.style.stroke = colorLerp(startColor, endColor, 0);
      updateCenterSeconds(remainingSec);
      timerDisplay.textContent = `Próxima em: ${remainingSec}s`;
      endTimer = setTimeout(()=>{ clearCountdown(); announceThenAdvance(); }, ringDuration);
      tickInterval = setInterval(()=>{
        if(isPaused) return;
        const elapsedMs = performance.now() - ringStartTime;
        const remMs = Math.max(0, ringDuration - elapsedMs);
        const rem = Math.ceil(remMs / 1000);
        updateCenterSeconds(rem);
        timerDisplay.textContent = `Próxima em: ${rem}s`;
      },150);
      function step(now){
        if(!ringStartTime || isPaused){ ringRaf = requestAnimationFrame(step); return; }
        const elapsedMs = now - ringStartTime;
        const progress = Math.min(1, elapsedMs / ringDuration);
        const offset = progress * CIRC;
        progressCircle.style.strokeDashoffset = `${offset}`;
        progressCircle.style.stroke = colorLerp(startColor, endColor, progress);
        if(progress < 1) ringRaf = requestAnimationFrame(step);
        else { progressCircle.style.strokeDashoffset = `${CIRC}`; progressCircle.style.stroke = colorLerp(startColor,endColor,1); }
      }
      ringRaf = requestAnimationFrame(step);
    }

    function updateCenterSeconds(n){ centerSeconds.textContent = `${n}s`; }

    function speakAndShow(text){
      currentWordEl.textContent = text;
      try { speechSynthesis.cancel(); } catch(e){}
      const u = new SpeechSynthesisUtterance(text); u.lang='pt-BR'; speechSynthesis.speak(u);
    }

    async function announceThenAdvance(){
      if(awaitingAnnouncement) return;
      if(pendingLaunch){ awaitingAnnouncement=false; return; }
      awaitingAnnouncement = true;
      try { try{ speechSynthesis.cancel(); } catch(e){}; await speakWithPromise('Próxima palavra', { interrupt:true, fallbackMs:900 }); }
      catch(e){} finally { awaitingAnnouncement = false; if(!isPaused && !pendingLaunch) advanceDictation(); else timerDisplay.textContent=''; }
    }

    function beginDictation(){
      index = 0; awaitingAnnouncement = false; speakAndShow(words[index]); nextBtn.disabled = false; startBtn.disabled = true;
      if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
    }

    function advanceDictation(fromManual=false){
      index++;
      if(index < words.length){ speakAndShow(words[index]); prevBtn.disabled = false; if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10))); }
      else finishDictation();
    }

    function finishDictation(){
      clearCountdown(); alert('Ditado concluído!'); currentWordEl.textContent = ''; nextBtn.disabled = true; prevBtn.disabled = true; startBtn.disabled = false; shuffleBtn.disabled = false;
      statusEl.textContent = `Concluído. Erros dinâmicos: ${wrongWords.length}`;
      isAuto = false; isPaused = false; pendingLaunch = false;
      hideMainTimerProxies(); hideMainErrorProxies();
    }

    function pauseAuto(){
      if(!isAuto || isPaused) return;
      isPaused = true;
      if(ringStartTime && ringDuration){ const elapsedMs = performance.now() - ringStartTime; const remMs = Math.max(0, ringDuration - elapsedMs); remainingSec = Math.max(0, Math.ceil(remMs / 1000)); }
      else remainingSec = Math.max(1, remainingSec || 1);
      clearCountdown();
      try { speechSynthesis.cancel(); } catch(e){}
      awaitingAnnouncement = false;
      statusEl.textContent = `Automático pausado. ${remainingSec}s restantes.`;
      setPauseVisual(true);
    }

    function resumeAuto(){
      if(!isAuto || !isPaused) return;
      isPaused = false;
      setPauseVisual(false);
      statusEl.textContent = 'Automático retomado.';
      try { speechSynthesis.cancel(); } catch(e){}
      speakAndShow(words[index]);
      const secToUse = Math.max(1, remainingSec || 1);
      if(!pendingLaunch) setCountdownFor(secToUse); else clearCountdown();
    }

    function setAutoVisual(on){
      if(on){ autoBtn.classList.remove('btn-outline-success'); autoBtn.classList.add('btn-success','pulse'); autoBtn.innerHTML = '<i class="bi bi-clock-history me-1"></i> Automático (ON)'; }
      else { autoBtn.classList.remove('btn-success','pulse'); autoBtn.classList.add('btn-outline-success'); autoBtn.innerHTML = '<i class="bi bi-clock-history me-1"></i> Automático'; }
      if(on) showMainTimerProxies(); else hideMainTimerProxies();
    }

    function setPauseVisual(paused){
      if(paused){ pauseProxy.classList.remove('btn-outline-warning'); pauseProxy.classList.add('btn-warning','active'); pauseProxy.innerHTML = '<i class="bi bi-play-fill me-1"></i> Retomar'; }
      else { pauseProxy.classList.remove('btn-warning','active'); pauseProxy.classList.add('btn-outline-warning'); pauseProxy.innerHTML = '<i class="bi bi-pause-fill me-1"></i> Pausar'; }
    }

    function setErrorToggleVisual(on){
      if(on){ toggleErrorBtn.classList.remove('btn-outline-danger'); toggleErrorBtn.classList.add('btn-danger','btn-err-active'); toggleErrorBtn.innerHTML = '<i class="bi bi-exclamation-triangle me-1"></i> Registro Ativo'; }
      else { toggleErrorBtn.classList.remove('btn-danger','btn-err-active'); toggleErrorBtn.classList.add('btn-outline-danger'); toggleErrorBtn.innerHTML = '<i class="bi bi-exclamation-triangle me-1"></i> Registrar Erradas (E)'; }
      if(on) showMainErrorProxies(); else hideMainErrorProxies();
    }

    function showMainTimerProxies(){
      const area = document.getElementById('mainTimerProxies');
      area.classList.remove('hidden'); area.setAttribute('aria-hidden','false');
      autoProxy.classList.remove('hidden'); pauseProxy.classList.remove('hidden');
      setPauseVisual(isPaused);
      autoProxy.innerHTML = isAuto ? '<i class="bi bi-clock-history me-1"></i> Automático (ON)' : '<i class="bi bi-clock-history me-1"></i> Automático';
      intervalInputProxy.value = intervalInputProxy.value || 3;
    }

    function hideMainTimerProxies(){
      const area = document.getElementById('mainTimerProxies');
      area.classList.add('hidden'); area.setAttribute('aria-hidden','true');
      autoProxy.classList.add('hidden'); pauseProxy.classList.add('hidden');
    }

    function showMainErrorProxies(){
      const area = document.getElementById('mainErrorProxies');
      area.classList.remove('hidden'); area.setAttribute('aria-hidden','false');
      addWrongProxy.classList.remove('hidden'); startErrorProxy.classList.remove('hidden'); clearErrorProxy.classList.remove('hidden');
      if(pendingLaunch) launchErrorProxy.classList.remove('hidden'); else launchErrorProxy.classList.add('hidden');
    }

    function hideMainErrorProxies(){
      const area = document.getElementById('mainErrorProxies');
      area.classList.add('hidden'); area.setAttribute('aria-hidden','true');
      addWrongProxy.classList.add('hidden'); startErrorProxy.classList.add('hidden'); launchErrorProxy.classList.add('hidden'); clearErrorProxy.classList.add('hidden');
    }

    // --- proxies event listeners ---
    autoProxy.addEventListener('click', () => { /* proxy forwards to master auto click */ autoBtn.click(); });

    /* ======= CORREÇÃO PRINCIPAL: pauseProxy agora chama as funções de pausa/retomar diretamente
       antes o código tentava acessar pauseBtn (que não existe) e travava.
       Agora: se isAuto=true e isPaused=false => pauseAuto(); se isPaused=true => resumeAuto(); */
    pauseProxy.addEventListener('click', () => {
      if (!isAuto) return; // only meaningful when automatic mode is active
      if (isPaused) resumeAuto(); else pauseAuto();
    });

    intervalInputProxy.addEventListener('change', (e) => {
      if(isAuto && !isPaused && !pendingLaunch){
        setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
      }
    });

    addWrongProxy.addEventListener('click', () => {
      if(!errorMode || !currentWordEl.textContent) return;
      const w = currentWordEl.textContent;
      if(!wrongWords.includes(w)){ wrongWords.push(w); statusEl.textContent = `"${w}" adicionada às erradas.`; renderWrongWords(); }
    });

    startErrorProxy.addEventListener('click', () => {
      if(!wrongWords.length) return;
      originalWrongWords = [...wrongWords];
      words = [...originalWrongWords];
      index = 0;
      statusEl.textContent = 'Preparado: pronto para iniciar revisão das erradas.';
      pendingLaunch = true;
      try { speechSynthesis.cancel(); } catch(e){}
      clearCountdown(); awaitingAnnouncement = false;
      launchErrorProxy.classList.remove('hidden');
      renderWrongWords();
    });

    launchErrorProxy.addEventListener('click', () => {
      launchErrorProxy.classList.add('hidden');
      index = 0; statusEl.textContent = 'Ditado de erradas iniciado.'; pendingLaunch = false; prevBtn.disabled = false;
      errorListSection.style.display = 'block'; errorListArea.value = originalWrongWords.join('\n'); wrongWords = []; renderWrongWords();
      beginDictation();
      if(isAuto && !isPaused){ awaitingAnnouncement=false; setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10))); }
    });

    clearErrorProxy.addEventListener('click', () => {
      wrongWords = []; originalWrongWords = []; renderWrongWords();
      errorListSection.style.display = 'none'; wrongSection.style.display = 'none';
      pendingLaunch = false; launchErrorProxy.classList.add('hidden'); hideMainErrorProxies();
    });

    // --- masters event listeners (essencialmente os mesmos comportamentos de antes) ---
    loadBtn.addEventListener('click', () => {
      const raw = wordListEl.value.trim();
      if(!raw) return alert('Insira ao menos uma palavra.');
      words = raw.split(/\r?\n/).map(w=>w.trim()).filter(Boolean);
      index = 0; isAuto = false; isPaused = false; wrongWords=[]; originalWrongWords=[];
      startBtn.disabled = false; shuffleBtn.disabled = false; prevBtn.disabled = true; nextBtn.disabled = true;
      currentWordEl.textContent=''; clearCountdown();
      statusEl.textContent = `Lista carregada: ${words.length} palavras.`;
      wrongSection.style.display='none'; errorListSection.style.display='none'; renderWrongWords();
      pendingLaunch = false; hideMainTimerProxies(); hideMainErrorProxies();
    });

    shuffleBtn.addEventListener('click', () => {
      for (let i = words.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [words[i], words[j]] = [words[j], words[i]]; }
      index = 0; statusEl.textContent='Lista embaralhada.'; renderWrongWords();
    });

    startBtn.addEventListener('click', () => { if(!words.length) return; wrongSection.style.display='none'; errorListSection.style.display='none'; beginDictation(); shuffleBtn.disabled=true; prevBtn.disabled=false; });

    autoBtn.addEventListener('click', () => {
      if(isAuto){
        isAuto = false; isPaused = false; clearCountdown(); setAutoVisual(false);
      } else {
        isAuto = true; isPaused = false; setAutoVisual(true);
        setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
      }
    });

    toggleErrorBtn.addEventListener('click', () => {
      errorMode = !errorMode;
      setErrorToggleVisual(errorMode);
      statusEl.textContent = errorMode ? 'Registro de erros ativado.' : 'Registro de erros desativado.';
    });

    prevBtn.addEventListener('click', () => {
      if(index > 0){ index--; speakAndShow(words[index]); nextBtn.disabled=false; if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10))); }
      if(index === 0) prevBtn.disabled = true;
    });

    nextBtn.addEventListener('click', () => { clearCountdown(); advanceDictation(true); });

    repeatBtn.addEventListener('click', () => {
      if(!words.length || !currentWordEl.textContent) return;
      repeatBtn.classList.add('btn-rotate');
      try{ speechSynthesis.cancel(); }catch(e){}
      const u=new SpeechSynthesisUtterance(words[index]); u.lang='pt-BR'; u.onend=()=>{ repeatBtn.classList.remove('btn-rotate'); };
      speechSynthesis.speak(u);
      setTimeout(()=>repeatBtn.classList.remove('btn-rotate'),1200);
    });

    document.addEventListener('keydown', (e) => {
      const active = document.activeElement && document.activeElement.tagName ? document.activeElement.tagName.toLowerCase() : '';
      if(active === 'input' || active === 'textarea') return;
      if(e.key === 'ArrowUp'){ e.preventDefault(); repeatBtn.click(); return; }
      if(errorMode && e.key.toLowerCase() === 'e' && currentWordEl.textContent){
        const w = currentWordEl.textContent; if(!wrongWords.includes(w)){ wrongWords.push(w); statusEl.textContent = `"${w}" adicionada às erradas.`; renderWrongWords(); }
      }
      if(e.key === 'ArrowRight'){ e.preventDefault(); if(!nextBtn.disabled) nextBtn.click(); } else if(e.key === 'ArrowLeft'){ e.preventDefault(); if(!prevBtn.disabled) prevBtn.click(); }
    });

    function renderWrongWords(){
      wrongWordsList.innerHTML = wrongWords.map(w => `<span class="chip" role="button" tabindex="0">${w} <i class="bi bi-x-lg ms-1"></i></span>`).join('');
      startErrorProxy.disabled = wrongWords.length === 0;
      clearErrorProxy.disabled = wrongWords.length === 0;
      wrongSection.style.display = (wrongWords.length>0 || errorMode) ? 'block' : 'none';
    }

    wrongWordsList.addEventListener('click', (e) => {
      let target = e.target;
      while(target && !target.classList.contains('chip')) target = target.parentElement;
      if(!target) return;
      const txt = target.textContent.trim();
      const w = txt.replace(/\s*×\s*$/,'').trim();
      const idx = wrongWords.indexOf(w);
      if(idx >= 0) wrongWords.splice(idx,1);
      renderWrongWords();
    });

    // unlock audio support for touch devices
    const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
    if(unlockAudioBtn && isTouchDevice){
      unlockAudioBtn.classList.remove('d-none');
      unlockAudioBtn.addEventListener('click', async () => {
        try { await speakWithPromise('Áudio ativado', { interrupt:true, fallbackMs:700 }); audioUnlocked=true; statusEl.textContent='Áudio ativado para este dispositivo.'; } catch(e){ statusEl.textContent='Não foi possível ativar áudio automaticamente.'; } finally { unlockAudioBtn.classList.add('d-none'); }
      });
    }

    // initial state
    hideMainTimerProxies(); hideMainErrorProxies();
    setAutoVisual(isAuto); setErrorToggleVisual(errorMode);
  </script>
</body>
</html>
