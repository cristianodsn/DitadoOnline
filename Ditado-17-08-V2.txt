<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ditado — Bootstrap (Timer Corrigido + Animações + Anel de Cor)</title>

  <!-- Bootstrap CSS (CDN) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">

  <!-- Bootstrap Icons -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">

  <style>
    :root{
      --muted:#6c757d;
      --accent:#10b981;
      --err:#dc2626;
    }

    body {
      background: linear-gradient(180deg,#f3f6fb,#ffffff);
      font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      padding: 28px;
    }

    .card {
      border-radius: 14px;
      box-shadow: 0 8px 30px rgba(17,24,39,0.06);
    }

    /* Micro interactions for buttons */
    .btn {
      transition: transform .12s ease, box-shadow .12s ease;
      border-radius: 10px;
    }
    .btn:hover { transform: translateY(-3px); }
    .btn:active { transform: translateY(-1px) scale(.995); }

    /* pulse for auto */
    .pulse {
      animation: pulse 1.6s infinite;
      box-shadow: 0 8px 32px rgba(16,185,129,0.12);
    }
    @keyframes pulse {
      0% { transform: translateY(0); }
      50% { transform: translateY(-3px); }
      100% { transform: translateY(0); }
    }

    /* heartbeat for error button - SLOWER (1.4s) */
    .btn-err-active {
      animation: heartbeat 1.4s infinite;
    }
    @keyframes heartbeat {
      0% { transform: scale(1); }
      14% { transform: scale(1.12); }
      28% { transform: scale(1); }
      42% { transform: scale(1.08); }
      70% { transform: scale(1); }
    }

    /* repeat button animation */
    .btn-repeat { transition: transform .14s ease, box-shadow .14s ease; }
    .btn-rotate {
      animation: rotatePulse 0.72s ease; /* rápida e elegante */
    }
    @keyframes rotatePulse {
      0% { transform: rotate(0deg) scale(1); }
      40% { transform: rotate(200deg) scale(1.06); }
      100% { transform: rotate(360deg) scale(1); }
    }

    /* current word styling */
    #currentWord {
      font-weight: 700;
      font-size: 2.2rem;
      color: #0b2545;
      min-height: 2.8rem;
      display:flex; align-items:center; justify-content:center;
    }

    #timerDisplay { color: var(--muted); font-weight:600; }

    /* wrong words chips */
    .chip { border-radius: 999px; padding: .35rem .75rem; margin: .25rem; display:inline-flex; align-items:center; gap:.5rem; background:#fff3f2; color:#7a0f0f; cursor:pointer; transition: transform .12s ease; }
    .chip:hover { transform: translateY(-4px); background:#ffdede; }

    /* Countdown ring layout */
    .countdown-wrap { display:flex; align-items:center; gap:1rem; justify-content:center; margin-top:10px; }
    .ring { width:72px; height:72px; position:relative; }
    .ring svg { transform: rotate(-90deg); width:100%; height:100%; }
    .ring .center-label { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-weight:700; color:#0b2545; font-size:0.95rem; }

    @media (max-width:576px) {
      #currentWord { font-size:1.6rem; }
      .ring { width:56px; height:56px; }
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="card p-4 mx-auto" style="max-width:900px;">
      <div class="d-flex align-items-center justify-content-between mb-3">
        <h3 class="mb-0">Ditado de Palavras</h3>
        <small class="text-muted">Bootstrap — Timer aprimorado</small>
      </div>

      <textarea id="wordList" class="form-control mb-3" rows="6" placeholder="Insira uma palavra por linha..."></textarea>

      <div class="row g-2 mb-2">
        <div class="col-auto">
          <button id="loadBtn" class="btn btn-primary btn-lg">
            <i class="bi bi-download me-2"></i>Carregar
          </button>
        </div>

        <div class="col-auto">
          <button id="startBtn" class="btn btn-success btn-lg" disabled>
            <i class="bi bi-play-fill me-2"></i>Iniciar
          </button>
        </div>

        <div class="col-auto">
          <button id="shuffleBtn" class="btn btn-outline-secondary btn-lg" disabled>
            <i class="bi bi-shuffle me-2"></i>Randomizar
          </button>
        </div>

        <div class="col-auto">
          <button id="prevBtn" class="btn btn-outline-dark btn-lg" disabled>
            <i class="bi bi-skip-start-fill me-1"></i> Voltar
          </button>
        </div>

        <div class="col-auto">
          <button id="nextBtn" class="btn btn-outline-dark btn-lg" disabled>
            Próxima <i class="bi bi-skip-end-fill ms-1"></i>
          </button>
        </div>

        <!-- Repetir -->
        <div class="col-auto">
          <button id="repeatBtn" class="btn btn-outline-primary btn-lg btn-repeat" title="Repetir palavra (Seta ↑)">
            <i class="bi bi-arrow-repeat"></i> Repetir
          </button>
        </div>

      </div>

      <div class="row align-items-center g-2 mb-3">
        <div class="col-auto d-flex align-items-center">
          <label class="me-2 fw-semibold" for="intervalInput">Intervalo (s)</label>
          <input id="intervalInput" type="number" min="1" value="3" class="form-control" style="width:100px;">
        </div>

        <div class="col-auto">
          <button id="autoBtn" class="btn btn-outline-success btn-sm" disabled>
            <i class="bi bi-clock-history me-1"></i> Automático
          </button>
        </div>

        <div class="col-auto">
          <button id="pauseBtn" class="btn btn-outline-warning btn-sm" disabled>
            <i class="bi bi-pause-fill me-1"></i> Pausar
          </button>
        </div>

        <div class="col-auto ms-auto">
          <button id="toggleErrorBtn" class="btn btn-outline-danger btn-sm" disabled>
            <i class="bi bi-exclamation-triangle me-1"></i> Registrar Erradas (E)
          </button>
        </div>

        <div class="col-auto">
          <button id="startErrorBtn" class="btn btn-danger btn-sm" disabled>
            <i class="bi bi-activity me-1"></i> Ditado Erradas
          </button>
        </div>

        <!-- NOVO: botão dedicado que aparece para iniciar a revisão -->
        <div class="col-auto">
          <button id="launchErrorBtn" class="btn btn-success btn-sm d-none" title="Iniciar revisão das erradas">
            <i class="bi bi-play-fill me-1"></i> Iniciar Erradas
          </button>
        </div>

        <div class="col-auto">
          <button id="clearErrorBtn" class="btn btn-outline-danger btn-sm" disabled>
            <i class="bi bi-trash me-1"></i> Limpar Erradas
          </button>
        </div>
      </div>

      <div class="text-center mb-2">
        <div id="currentWord"></div>

        <div class="countdown-wrap">
          <div class="ring" aria-hidden="true">
            <svg id="countdownSvg" viewBox="0 0 100 100" role="img" aria-label="Contador">
              <circle cx="50" cy="50" r="44" stroke="#e6e6e6" stroke-width="10" fill="none"></circle>
              <circle id="progressCircle" cx="50" cy="50" r="44" stroke="#10b981" stroke-width="10" stroke-linecap="round" fill="none" stroke-dasharray="276.46" stroke-dashoffset="0"></circle>
            </svg>
            <div class="center-label" id="centerSeconds">-</div>
          </div>

          <div>
            <div id="timerDisplay" class="small"></div>
            <div id="status" class="text-muted small mt-1"></div>
          </div>
        </div>

      </div>

      <div id="wrongSection" class="mt-3" style="display:none;">
        <h6 class="mb-2 text-danger">Palavras Erradas (clique para remover)</h6>
        <div id="wrongWordsList"></div>
      </div>

      <div id="errorListSection" class="mt-3" style="display:none;">
        <h6 class="mb-2 text-secondary">Revisão (lista original de erradas)</h6>
        <textarea id="errorListArea" class="form-control" rows="4" readonly></textarea>
      </div>

      <div class="mt-3 text-muted small">
        Dica: use ← e → para navegar; pressione <span class="fw-bold">E</span> para marcar a palavra atual como errada (quando o registro estiver ativo). Pressione <span class="fw-bold">↑</span> para repetir a palavra.
      </div>
    </div>
  </div>

  <!-- Bootstrap JS (bundle) -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" defer></script>

  <script defer>
    // Elementos
    const loadBtn = document.getElementById('loadBtn');
    const startBtn = document.getElementById('startBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const repeatBtn = document.getElementById('repeatBtn');
    const autoBtn = document.getElementById('autoBtn');
    const pauseBtn = document.getElementById('pauseBtn');
    const intervalInput = document.getElementById('intervalInput');
    const toggleErrorBtn = document.getElementById('toggleErrorBtn');
    const startErrorBtn = document.getElementById('startErrorBtn');
    const launchErrorBtn = document.getElementById('launchErrorBtn'); // novo botão
    const clearErrorBtn = document.getElementById('clearErrorBtn');
    const wordListEl = document.getElementById('wordList');
    const currentWordEl = document.getElementById('currentWord');
    const timerDisplay = document.getElementById('timerDisplay');
    const statusEl = document.getElementById('status');
    const wrongSection = document.getElementById('wrongSection');
    const wrongWordsList = document.getElementById('wrongWordsList');
    const errorListSection = document.getElementById('errorListSection');
    const errorListArea = document.getElementById('errorListArea');

    // Countdown ring elements
    const progressCircle = document.getElementById('progressCircle');
    const centerSeconds = document.getElementById('centerSeconds');

    // Estado
    let words = [];
    let wrongWords = [];
    let originalWrongWords = [];
    let index = 0;
    let errorMode = false;

    // timing & animation handles
    let ringRaf = null;
    let ringStartTime = null;
    let ringDuration = null;
    let endTimer = null;        // setTimeout to trigger end
    let tickInterval = null;    // numeric display updater

    let remainingSec = 0;          // seconds remaining (integer)
    let isAuto = false;
    let isPaused = false;
    let awaitingAnnouncement = false;

    // NOVO: pendingLaunch indica que a lista de "erradas" está preparada mas AINDA não deve iniciar automaticamente
    let pendingLaunch = false;

    // circle geometry
    const R = 44;
    const CIRC = 2 * Math.PI * R; // circumference
    progressCircle.style.strokeDasharray = `${CIRC}`;
    progressCircle.style.strokeDashoffset = `0`;

    // color endpoints (verde -> vermelho)
    const startColor = { r: 16, g: 185, b: 129 }; // #10b981
    const endColor = { r: 220, g: 38, b: 38 };    // #dc2626

    // helper: linear interpolation between two numbers
    function lerp(a, b, t) { return Math.round(a + (b - a) * t); }
    function colorLerp(c1, c2, t) {
      return `rgb(${lerp(c1.r, c2.r, t)}, ${lerp(c1.g, c2.g, t)}, ${lerp(c1.b, c2.b, t)})`;
    }

    /* ---------------------------
       small speech helper: returns a Promise that resolves onend or on fallback timeout
       - interrupt: if true, cancels existing speech before speaking
       - fallbackMs: timeout to resolve if onend not fired
       --------------------------- */
    function speakWithPromise(text, { interrupt = true, fallbackMs = 1200 } = {}) {
      return new Promise((resolve) => {
        try { if (interrupt) speechSynthesis.cancel(); } catch(e){}
        const u = new SpeechSynthesisUtterance(text);
        u.lang = 'pt-BR';
        let resolved = false;
        u.onend = () => { if (!resolved) { resolved = true; resolve(); } };
        u.onerror = () => { if (!resolved) { resolved = true; resolve(); } };
        // fallback safety
        const guard = setTimeout(() => { if (!resolved) { resolved = true; resolve(); } }, fallbackMs + 400);
        // wrap resolve to clear guard
        const originalResolve = resolve;
        resolve = () => { clearTimeout(guard); originalResolve(); };

        try { speechSynthesis.speak(u); } catch(e) { resolve(); }
      });
    }

    /* ---------------------------
       Helpers visuais / UI
       --------------------------- */
    function setAutoVisual(on) {
      if (on) {
        autoBtn.classList.remove('btn-outline-success');
        autoBtn.classList.add('btn-success','pulse');
        autoBtn.innerHTML = '<i class="bi bi-clock-history me-1"></i> Automático (ON)';
        pauseBtn.disabled = false;
      } else {
        autoBtn.classList.remove('btn-success','pulse');
        autoBtn.classList.add('btn-outline-success');
        autoBtn.innerHTML = '<i class="bi bi-clock-history me-1"></i> Automático';
        pauseBtn.disabled = true;
      }
    }

    function setPauseVisual(paused) {
      if (paused) {
        pauseBtn.classList.remove('btn-outline-warning');
        pauseBtn.classList.add('btn-warning','active');
        pauseBtn.innerHTML = '<i class="bi bi-play-fill me-1"></i> Retomar';
      } else {
        pauseBtn.classList.remove('btn-warning','active');
        pauseBtn.classList.add('btn-outline-warning');
        pauseBtn.innerHTML = '<i class="bi bi-pause-fill me-1"></i> Pausar';
      }
    }

    function setErrorToggleVisual(on) {
      toggleErrorBtn.classList.toggle('active', on);
      if (on) {
        toggleErrorBtn.classList.remove('btn-outline-danger');
        toggleErrorBtn.classList.add('btn-danger','btn-err-active');
      } else {
        toggleErrorBtn.classList.remove('btn-danger','btn-err-active');
        toggleErrorBtn.classList.add('btn-outline-danger');
      }
    }

    function renderWrongWords() {
      wrongWordsList.innerHTML = wrongWords.map(w => {
        return `<span class="chip" role="button" tabindex="0">${w} <i class="bi bi-x-lg ms-1"></i></span>`;
      }).join('');
      startErrorBtn.disabled = wrongWords.length === 0;
      clearErrorBtn.disabled = wrongWords.length === 0;
      wrongSection.style.display = (wrongWords.length>0 || errorMode) ? 'block' : 'none';
    }

    /* ---------------------------
       Countdown: robust implementation using:
         - setTimeout to trigger end reliably (endTimer)
         - requestAnimationFrame for smooth ring + dynamic color
         - tickInterval for seconds numeric update
       pause/resume compute remainingSec and restart correctly
       --------------------------- */

    function clearCountdown() {
      if (endTimer) { clearTimeout(endTimer); endTimer = null; }
      if (tickInterval) { clearInterval(tickInterval); tickInterval = null; }
      if (ringRaf) { cancelAnimationFrame(ringRaf); ringRaf = null; }
      ringStartTime = null;
      ringDuration = null;
      // reset ring to start (no offset) and color back to green
      progressCircle.style.transition = 'stroke-dashoffset 240ms linear, stroke 240ms linear';
      progressCircle.style.strokeDashoffset = '0';
      progressCircle.style.stroke = colorLerp(startColor, endColor, 0); // verde
      centerSeconds.textContent = '-';
      timerDisplay.textContent = '';
    }

    function setCountdownFor(sec) {
      // Se estivermos aguardando que o usuário inicie a lista de erradas,
      // não devemos iniciar o cronômetro automaticamente.
      if (pendingLaunch) {
        // assegura que não há timers remanescentes
        clearCountdown();
        return;
      }

      // sec: integer seconds to count down (>=1)
      clearCountdown();

      remainingSec = Math.max(1, Math.floor(sec) || 1);
      ringDuration = remainingSec * 1000;
      ringStartTime = performance.now();

      // visuals init
      progressCircle.style.transition = 'none';
      progressCircle.style.stroke = colorLerp(startColor, endColor, 0); // start green
      updateCenterSeconds(remainingSec);
      timerDisplay.textContent = `Próxima em: ${remainingSec}s`;

      // set endTimer to trigger announceThenAdvance reliably
      endTimer = setTimeout(() => {
        // ensure clean state
        clearCountdown();
        announceThenAdvance();
      }, ringDuration);

      // tickInterval updates numeric display every ~150ms (coarse)
      tickInterval = setInterval(() => {
        if (isPaused) return;
        const elapsedMs = performance.now() - ringStartTime;
        const remMs = Math.max(0, ringDuration - elapsedMs);
        const rem = Math.ceil(remMs / 1000);
        updateCenterSeconds(rem);
        timerDisplay.textContent = `Próxima em: ${rem}s`;
      }, 150);

      // smooth ring animation via RAF (also updates stroke color)
      function step(now) {
        if (!ringStartTime || isPaused) {
          ringRaf = requestAnimationFrame(step);
          return;
        }
        const elapsedMs = now - ringStartTime;
        const progress = Math.min(1, elapsedMs / ringDuration); // 0..1
        const offset = progress * CIRC;
        progressCircle.style.strokeDashoffset = `${offset}`;

        // color interpolation: progress 0 -> green, 1 -> red
        progressCircle.style.stroke = colorLerp(startColor, endColor, progress);

        if (progress < 1) {
          ringRaf = requestAnimationFrame(step);
        } else {
          // ensure fully drawn and fully red
          progressCircle.style.strokeDashoffset = `${CIRC}`;
          progressCircle.style.stroke = colorLerp(startColor, endColor, 1);
        }
      }
      ringRaf = requestAnimationFrame(step);
    }

    function updateCenterSeconds(n) {
      centerSeconds.textContent = `${n}s`;
    }

    /* ---------------------------
       Core ditado / navegação
       --------------------------- */

    loadBtn.addEventListener('click', () => {
      const raw = wordListEl.value.trim();
      if (!raw) return alert('Insira ao menos uma palavra.');
      words = raw.split(/\r?\n/).map(w => w.trim()).filter(Boolean);
      index = 0; isAuto = false; isPaused = false;
      wrongWords = []; originalWrongWords = [];
      startBtn.disabled = false; shuffleBtn.disabled = false; autoBtn.disabled = false; pauseBtn.disabled = true;
      nextBtn.disabled = true; prevBtn.disabled = true; toggleErrorBtn.disabled = false;
      currentWordEl.textContent = ''; clearCountdown();
      statusEl.textContent = `Lista carregada: ${words.length} palavras.`;
      wrongSection.style.display = 'none';
      errorListSection.style.display = 'none';
      renderWrongWords();
      // hide any existing launch button and clear pendingLaunch
      launchErrorBtn.classList.add('d-none');
      pendingLaunch = false;
    });

    shuffleBtn.addEventListener('click', () => {
      for (let i = words.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [words[i], words[j]] = [words[j], words[i]];
      }
      index = 0;
      statusEl.textContent = 'Lista embaralhada.';
      renderWrongWords();
    });

    startBtn.addEventListener('click', () => {
      if (!words.length) return;
      wrongSection.style.display = 'none';
      errorListSection.style.display = 'none';
      beginDictation();
      shuffleBtn.disabled = true;
      prevBtn.disabled = false;
      startBtn.classList.add('active');
    });

    startErrorBtn.addEventListener('click', () => {
      // Ao clicar em "Ditado Erradas" agora PREPARAMOS a lista e mostramos o botão "Iniciar Erradas"
      if (!wrongWords.length) return;
      originalWrongWords = [...wrongWords];
      words = [...originalWrongWords];
      index = 0;
      statusEl.textContent = 'Preparado: pronto para iniciar revisão das erradas.';
      shuffleBtn.disabled = true;
      prevBtn.disabled = false;
      errorListSection.style.display = 'block';
      errorListArea.value = originalWrongWords.join('\n');
      // limpamos temporariamente a lista dinâmica (como antes)
      wrongWords = [];
      renderWrongWords();

      // Definimos que estamos aguardando o lançamento manual
      pendingLaunch = true;

      // Cancelar qualquer contagem/announcements em andamento para evitar avançar automaticamente
      try { speechSynthesis.cancel(); } catch(e){}
      clearCountdown();
      awaitingAnnouncement = false;

      // Mostra o botão dedicado para iniciar a revisão — o usuário decide quando começar
      launchErrorBtn.classList.remove('d-none');
      // Desabilita o botão "Ditado Erradas" para evitar cliques repetidos enquanto aguardamos iniciar
      startErrorBtn.disabled = true;
      statusEl.textContent = 'Clique em "Iniciar Erradas" quando desejar começar a revisão.';
    });

    // Evento do novo botão: iniciar efetivamente a revisão das erradas
    launchErrorBtn.addEventListener('click', () => {
      // inicia a revisão exatamente como antes
      launchErrorBtn.classList.add('d-none'); // esconde o botão de início dedicado
      startErrorBtn.disabled = false; // re-habilita o botão original
      index = 0;
      statusEl.textContent = 'Ditado de erradas iniciado.';
      // limpar flag de pendência
      pendingLaunch = false;
      // startErrorBtn behavior: set words (already set), set UI and start
      prevBtn.disabled = false;
      errorListSection.style.display = 'block';
      errorListArea.value = originalWrongWords.join('\n');
      wrongWords = [];
      renderWrongWords();
      beginDictation();

      // Se estiver em modo automático, iniciar o contador para a palavra atual
      if (isAuto && !isPaused) {
        awaitingAnnouncement = false;
        setCountdownFor(Math.max(1, parseInt(intervalInput.value,10)));
      }
    });

    prevBtn.addEventListener('click', () => {
      if (index > 0) {
        index--;
        // speak current word and, se não estivermos pendentes por lançamento, reiniciar countdown
        speakAndShow(words[index]);
        nextBtn.disabled = false;
        if (isAuto && !isPaused && !pendingLaunch) {
          // restart countdown for the new index
          setCountdownFor(Math.max(1, parseInt(intervalInput.value,10)));
        }
      }
      if (index === 0) prevBtn.disabled = true;
    });

    nextBtn.addEventListener('click', () => {
      // manual advance: clear countdown then advance
      clearCountdown();
      advanceDictation(true);
    });

    // Repetir
    repeatBtn.addEventListener('click', () => repeatWord());

    autoBtn.addEventListener('click', () => {
      if (isAuto) {
        clearAutoMode();
      } else {
        startAutoMode();
      }
    });

    pauseBtn.addEventListener('click', () => {
      if (isPaused) resumeAuto();
      else pauseAuto();
    });

    toggleErrorBtn.addEventListener('click', () => {
      errorMode = !errorMode;
      setErrorToggleVisual(errorMode);
      toggleErrorBtn.setAttribute('aria-pressed', errorMode ? 'true' : 'false');
      toggleErrorBtn.innerHTML = `<i class="bi bi-exclamation-triangle me-1"></i> ${errorMode ? 'Registro Ativo' : 'Registrar Erradas (E)'}`;
      statusEl.textContent = errorMode ? 'Registro de erros ativado.' : 'Registro de erros desativado.';
      renderWrongWords();
    });

    clearErrorBtn.addEventListener('click', () => {
      wrongWords = []; originalWrongWords = [];
      clearErrorBtn.disabled = true; startErrorBtn.disabled = true;
      statusEl.textContent = 'Lista de erradas limpa.';
      wrongSection.style.display = 'none'; errorListSection.style.display = 'none'; renderWrongWords();
      // esconde botão dedicado se estiver visível e cancela pendência
      launchErrorBtn.classList.add('d-none');
      pendingLaunch = false;
    });

    document.addEventListener('keydown', (e) => {
      const active = document.activeElement && document.activeElement.tagName ? document.activeElement.tagName.toLowerCase() : '';
      if (active === 'input' || active === 'textarea') return;

      // ArrowUp -> repetir
      if (e.key === 'ArrowUp') {
        e.preventDefault();
        repeatWord();
        return;
      }

      if (errorMode && e.key.toLowerCase() === 'e' && currentWordEl.textContent) {
        const w = currentWordEl.textContent;
        if (!wrongWords.includes(w)) {
          wrongWords.push(w);
          statusEl.textContent = `"${w}" adicionada às erradas.`;
          clearErrorBtn.disabled = false; startErrorBtn.disabled = false;
          renderWrongWords();
        }
      }

      if (e.key === 'ArrowRight') {
        e.preventDefault();
        if (!nextBtn.disabled) nextBtn.click();
      } else if (e.key === 'ArrowLeft') {
        e.preventDefault();
        if (!prevBtn.disabled) prevBtn.click();
      }
    });

    wrongWordsList.addEventListener('click', (e) => {
      let target = e.target;
      while (target && !target.classList.contains('chip')) {
        target = target.parentElement;
      }
      if (!target) return;
      const txt = target.textContent.trim();
      const w = txt.replace(/\s*×\s*$/,'').trim();
      const idx = wrongWords.indexOf(w);
      if (idx >= 0) wrongWords.splice(idx,1);
      renderWrongWords();
    });

    function beginDictation() {
      index = 0;
      // ensure flags cleared for normal dictation start
      awaitingAnnouncement = false;
      speakAndShow(words[index]);
      nextBtn.disabled = false;
      startBtn.disabled = true;

      // CORREÇÃO: se já estivermos em modo automático e NÃO estivermos aguardando o lançamento, iniciar o contador para a palavra atual
      if (isAuto && !isPaused && !pendingLaunch) {
        setCountdownFor(Math.max(1, parseInt(intervalInput.value,10)));
      }
    }

    function advanceDictation(fromManual=false) {
      index++;
      if (index < words.length) {
        speakAndShow(words[index]);
        prevBtn.disabled = false;
        // If auto mode is on and not paused and not pending launch, start new countdown
        if (isAuto && !isPaused && !pendingLaunch) {
          setCountdownFor(Math.max(1, parseInt(intervalInput.value,10)));
        }
      } else {
        finishDictation();
      }
    }

    function startAutoMode() {
      const sec = Math.max(1, parseInt(intervalInput.value,10));
      remainingSec = sec;
      isAuto = true; isPaused = false;
      setAutoVisual(true);
      setPauseVisual(false);
      statusEl.textContent = 'Modo automático ativado.';
      // speak current word (if nothing spoken yet or to refresh)
      if (!currentWordEl.textContent) speakAndShow(words[index]);
      // start countdown for the current index ONLY if we are NOT pending launch
      if (!pendingLaunch) {
        setCountdownFor(Math.max(1, sec));
      } else {
        // se estamos pendentes, garantimos que não vamos iniciar o cronômetro
        clearCountdown();
      }
    }

    // announceThenAdvance: robust -> speaks "Próxima palavra", waits (via speakWithPromise) and then advances
    async function announceThenAdvance() {
      if (awaitingAnnouncement) return;
      // Se estivermos aguardando que o usuário clique "Iniciar Erradas", não anunciamos/avançamos automaticamente
      if (pendingLaunch) {
        awaitingAnnouncement = false;
        return;
      }

      awaitingAnnouncement = true;
      try {
        // ensure no overlapping speech
        try { speechSynthesis.cancel(); } catch(e){}
        // speak and wait (fallback inside speakWithPromise)
        await speakWithPromise('Próxima palavra', { interrupt: true, fallbackMs: 900 });
      } catch (e) {
        // ignore
      } finally {
        awaitingAnnouncement = false;
        if (!isPaused && !pendingLaunch) {
          advanceDictation();
        } else {
          timerDisplay.textContent = '';
        }
      }
    }

    function pauseAuto() {
      if (!isAuto || isPaused) return;
      isPaused = true;

      // compute precise remaining milliseconds from ringStartTime / ringDuration
      if (ringStartTime && ringDuration) {
        const elapsedMs = performance.now() - ringStartTime;
        const remMs = Math.max(0, ringDuration - elapsedMs);
        remainingSec = Math.max(0, Math.ceil(remMs / 1000));
      } else {
        remainingSec = Math.max(1, remainingSec || 1);
      }

      // stop timers & animations
      clearCountdown();

      // cancel any current speech to avoid stuck onend
      try { speechSynthesis.cancel(); } catch(e){}

      // ensure announcement flag cleared to avoid deadlock
      awaitingAnnouncement = false;

      setPauseVisual(true);
      statusEl.textContent = `Automático pausado. ${remainingSec}s restantes.`;
    }

    function resumeAuto() {
      if (!isAuto || !isPaused) return;
      isPaused = false;
      setPauseVisual(false);
      statusEl.textContent = 'Automático retomado.';
      // re-speak current word and restart countdown with remainingSec
      try { speechSynthesis.cancel(); } catch(e){}
      speakAndShow(words[index]);
      const secToUse = Math.max(1, remainingSec || 1);
      // Somente inicia o contador se NÃO estivermos aguardando a inicialização manual das erradas
      if (!pendingLaunch) {
        setCountdownFor(secToUse);
      } else {
        // se pendente, não iniciar o cronômetro automaticamente
        clearCountdown();
      }
    }

    function clearAutoMode() {
      clearCountdown();
      isAuto = false;
      isPaused = false;
      setAutoVisual(false);
      setPauseVisual(false);
      statusEl.textContent = 'Automático desativado.';
      nextBtn.disabled = index >= words.length-1;
      prevBtn.disabled = index === 0;
    }

    function finishDictation() {
      clearCountdown();
      alert('Ditado concluído!');
      currentWordEl.textContent = '';
      nextBtn.disabled = true;
      prevBtn.disabled = true;
      startBtn.disabled = false;
      shuffleBtn.disabled = false;
      autoBtn.disabled = false;
      pauseBtn.disabled = true;
      statusEl.textContent = `Concluído. Erros dinâmicos: ${wrongWords.length}`;
      setAutoVisual(false);
      setPauseVisual(false);
      isAuto = false;
      isPaused = false;
      pendingLaunch = false;
    }

    // Repetir palavra (com animação no botão)
    function repeatWord() {
      if (!words.length || !currentWordEl.textContent) return;
      repeatBtn.classList.add('btn-rotate');
      try { speechSynthesis.cancel(); } catch(e){}
      const u = new SpeechSynthesisUtterance(words[index]);
      u.lang = 'pt-BR';
      u.onend = () => { repeatBtn.classList.remove('btn-rotate'); };
      speechSynthesis.speak(u);
      setTimeout(() => repeatBtn.classList.remove('btn-rotate'), 1200);
    }

    // speakAndShow: show word and speak (non-blocking)
    function speakAndShow(text) {
      currentWordEl.textContent = text;
      try { speechSynthesis.cancel(); } catch(e){}
      const u = new SpeechSynthesisUtterance(text);
      u.lang = 'pt-BR';
      speechSynthesis.speak(u);
    }
  </script>
</body>
</html>
