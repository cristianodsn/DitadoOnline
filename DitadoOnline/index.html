<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Ditado — Opções (Timer / Erradas / Narrador)</title>

  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.11.3/font/bootstrap-icons.css" rel="stylesheet">

  <style>
    :root{ --muted:#6c757d; --accent:#10b981; --err:#dc2626; }
    body { background: linear-gradient(180deg,#f3f6fb,#ffffff); font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding: 18px; }
    .card { border-radius: 14px; box-shadow: 0 8px 30px rgba(17,24,39,0.06); }
    .btn { transition: transform .12s ease, box-shadow .12s ease; border-radius: 10px; -webkit-tap-highlight-color: rgba(0,0,0,0); }
    .btn:hover { transform: translateY(-3px); } .btn:active { transform: translateY(-1px) scale(.995); }
    .btn.touch-large { min-height:48px; padding-top:.6rem; padding-bottom:.6rem; }
    .btn-config.pulse { animation: pulse 1.6s infinite; box-shadow: 0 8px 32px rgba(16,185,129,0.12); }
    @keyframes pulse { 0%{transform:translateY(0)}50%{transform:translateY(-3px)}100%{transform:translateY(0)} }
    .btn-rotate { animation: rotatePulse 0.72s ease; } @keyframes rotatePulse { 0%{transform:rotate(0deg) scale(1)}40%{transform:rotate(200deg) scale(1.06)}100%{transform:rotate(360deg) scale(1)} }
    #currentWord{ font-weight:700; font-size:2.2rem; color:#0b2545; min-height:2.8rem; display:flex; align-items:center; justify-content:center; }
    #timerDisplay{ color:var(--muted); font-weight:600; }
    .chip{ border-radius:999px; padding:.35rem .75rem; margin:.25rem; display:inline-flex; align-items:center; gap:.5rem; background:#fff3f2; color:#7a0f0f; cursor:pointer; transition: transform .12s ease; }
    .chip:hover{ transform: translateY(-4px); background:#ffdede; }
    .countdown-wrap{ display:flex; align-items:center; gap:1rem; justify-content:center; margin-top:10px; position:relative; }
    .ring{ width:72px; height:72px; position:relative; } .ring svg{ transform: rotate(-90deg); width:100%; height:100%; display:block; }
    .ring .center-label{ position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-weight:700; color:#0b2545; font-size:0.95rem; }

    .inactive-clock { position:absolute; inset:0; display:flex; align-items:center; justify-content:center; font-size:28px; color:#6c757d; pointer-events:none; transition: transform .45s cubic-bezier(.2,.9,.3,1), opacity .35s ease; }
    .inactive-clock.hidden { opacity:0; transform: scale(.92) rotate(-10deg); pointer-events:none; }
    .inactive-clock.visible { opacity:1; transform: scale(1) rotate(0deg); }

    .anim-to-ring { animation: clockToRing .52s ease forwards; }
    @keyframes clockToRing {
      0% { transform: scale(1) rotate(0deg); opacity:1; }
      40% { transform: scale(1.18) rotate(12deg); opacity:0.85; }
      100% { transform: scale(.9) rotate(40deg); opacity:0; }
    }

    .progress-transition { transition: stroke 420ms linear, stroke-dashoffset 240ms linear; }

    /* espaçamentos */
    .controls-top { margin-bottom: 18px; display:flex; align-items:center; gap:12px; }
    .controls-bottom { margin-bottom: 18px; }
    #mainProxiesArea { margin: 18px 0; }

    @media (max-width:768px){
      .controls-top .col-auto{ width:100%; } .controls-top .btn{ width:100%; }
      .controls-bottom .col-auto{ width:100%; } .controls-bottom .btn{ width:100%; }
      .countdown-wrap{ flex-direction:column; gap:.5rem; } .ring{ width:86px; height:86px; } #currentWord{ font-size:1.6rem; }
      .keyboard-hint{ display:none !important; }
      .inactive-clock { font-size: 30px; } /* keep proportion on mobile */
    }
    @media (max-width:576px){ .ring{ width:64px; height:64px; } #currentWord{ font-size:1.4rem; } .inactive-clock { font-size:26px; } }
    .spaced-section{ margin-top:18px; margin-bottom:18px; }

    .proxy-btn { min-width: 120px; }
    .main-proxies { margin-bottom: 14px; display:flex; gap:.5rem; flex-wrap:wrap; justify-content:center; }
    .hidden { display:none !important; }

    /* help button — 30% menor (~26px) */
    .help-btn {
      width:26px; height:26px; border-radius:50%; padding:0; display:inline-flex; align-items:center; justify-content:center;
      background: linear-gradient(180deg,#0d6efd,#0069d9); color:white; border: none;
      box-shadow: 0 6px 16px rgba(13,110,253,0.18); font-weight:600; font-size:13px;
      transition: transform .12s ease, box-shadow .12s ease, opacity .12s ease;
    }
    .help-btn:hover { transform: translateY(-3px) scale(1.03); box-shadow: 0 10px 22px rgba(13,110,253,0.22); opacity: .98; }
    .help-btn:active { transform: translateY(-1px) scale(.99); }

    .offcanvas .mb-3 h6 { margin-bottom: 6px; }

    /* pequeno espaçamento para o bloco de erradas sob o timer */
    #errorProxiesUnderTimer { margin-top: 12px; display:flex; gap:.5rem; justify-content:center; flex-wrap:wrap; }

    /* animação para aparição do botão Refazer Erradas */
    @keyframes popInRedo {
      0%   { transform: translateY(-8px) scale(.95); opacity: 0; }
      60%  { transform: translateY(4px)  scale(1.03); opacity: 1; }
      100% { transform: translateY(0)    scale(1);    opacity: 1; }
    }
    .redo-appear {
      animation: popInRedo 420ms cubic-bezier(.2,.9,.3,1);
    }

    /* total display style (fixo próximo aos controles) */
    #totalCountDisplay { min-width:180px; text-align:right; color:var(--muted); font-weight:600; }
  </style>
</head>
<body>
  <div class="container">
    <div class="card p-3 mx-auto" style="max-width:980px;">
      <div class="d-flex align-items-center justify-content-between mb-2">
        <h3 class="mb-0">Ditado de Palavras</h3>
        <div>
          <button id="configBtn" class="btn btn-outline-secondary btn-config pulse" data-bs-toggle="offcanvas" data-bs-target="#configOffcanvas" aria-controls="configOffcanvas" title="Opções">
            <i class="bi bi-gear-fill"></i> Opções
          </button>
        </div>
      </div>

      <!-- TOP: Carregar / Iniciar / Randomizar + total fixo -->
      <div class="row g-2 mb-2 controls-top align-items-center">
        <div class="col-auto">
          <button id="loadBtn" class="btn btn-primary btn-lg touch-large">
            <i class="bi bi-download me-2"></i>Carregar
          </button>
        </div>

        <div class="col-auto">
          <button id="startBtn" class="btn btn-success btn-lg touch-large" disabled>
            <i class="bi bi-play-fill me-2"></i>Iniciar
          </button>
        </div>

        <div class="col-auto">
          <button id="shuffleBtn" class="btn btn-outline-secondary btn-lg touch-large" disabled>
            <i class="bi bi-shuffle me-2"></i>Randomizar
          </button>
        </div>

        <!-- total fixo de palavras carregadas -->
        <div class="col text-end">
          <div id="totalCountDisplay" class="small text-muted">Carregadas: 0</div>
        </div>
      </div>

      <textarea id="wordList" class="form-control mb-3" rows="6" placeholder="Insira uma palavra por linha..."></textarea>

      <!-- BOTTOM: Voltar / Próxima / Repetir -->
      <div class="row g-2 mb-3 controls-bottom justify-content-center">
        <div class="col-auto">
          <button id="prevBtn" class="btn btn-outline-dark btn-lg touch-large" disabled>
            <i class="bi bi-skip-start-fill me-1"></i> Voltar
          </button>
        </div>

        <div class="col-auto">
          <button id="nextBtn" class="btn btn-outline-dark btn-lg touch-large" disabled>
            Próxima <i class="bi bi-skip-end-fill ms-1"></i>
          </button>
        </div>

        <div class="col-auto">
          <button id="repeatBtn" class="btn btn-outline-primary btn-lg btn-repeat touch-large" title="Repetir palavra (Seta ↑)">
            <i class="bi bi-arrow-repeat"></i> Repetir
          </button>
        </div>
      </div>

      <!-- Timer proxies (continuam aqui) -->
      <div id="mainProxiesArea" class="text-center mb-3">
        <div id="mainTimerProxies" class="main-proxies hidden" aria-hidden="true">
          <input id="intervalInputProxy" type="number" min="1" value="3" class="form-control" style="width:120px;">
          <button id="startTimerProxy" class="btn btn-success proxy-btn hidden">Iniciar Timer</button>
          <button id="pauseProxy" class="btn btn-warning proxy-btn hidden" title="Pausar (proxy)"><i class="bi bi-pause-fill me-1"></i> Pausar</button>
        </div>
      </div>

      <!-- Área central: palavra e contador (com ícone inativo) -->
      <div class="text-center mb-2 spaced-section">
        <div id="currentWord"></div>

        <div class="countdown-wrap" aria-hidden="false">
          <div class="ring" aria-hidden="true">
            <!-- SVG ring (progresso) -->
            <svg id="countdownSvg" viewBox="0 0 100 100" role="img" aria-label="Contador" style="display:block;">
              <circle cx="50" cy="50" r="44" stroke="#e6e6e6" stroke-width="10" fill="none"></circle>
              <circle id="progressCircle" cx="50" cy="50" r="44" stroke="#10b981" stroke-width="10" stroke-linecap="round" fill="none" stroke-dasharray="276.46" stroke-dashoffset="0" class="progress-transition"></circle>
            </svg>
            <!-- centro com segundos -->
            <div class="center-label" id="centerSeconds">-</div>
            <!-- ícone de relógio inativo (mostrado quando timer desativado) -->
            <div id="inactiveClock" class="inactive-clock visible" aria-hidden="true"><i class="bi bi-alarm"></i></div>
          </div>

          <div>
            <div id="timerDisplay" class="small"></div>
            <div id="status" class="text-muted small mt-1">Timer Desativado</div>
          </div>
        </div>

        <!-- bloco de botões de Ditado de Erradas (abaixo do timer) -->
        <div id="errorProxiesUnderTimer" class="mt-2">
          <div id="mainErrorProxies" class="main-proxies hidden" aria-hidden="true">
            <button id="addWrongProxy" class="btn btn-outline-danger proxy-btn">Adicionar Errada</button>
            <button id="startErrorProxy" class="btn btn-danger proxy-btn">Ditado Erradas</button>
            <button id="redoWrongProxy" class="btn btn-secondary proxy-btn hidden">Refazer Erradas</button>
            <button id="launchErrorProxy" class="btn btn-success proxy-btn hidden">Iniciar Erradas</button>
            <button id="clearErrorProxy" class="btn btn-outline-danger proxy-btn">Limpar Erradas</button>
          </div>
        </div>
      </div>

      <div id="wrongSection" class="mt-3" style="display:none;">
        <h6 class="mb-2 text-danger">Palavras Erradas (clique para remover)</h6>
        <div id="wrongWordsList"></div>
      </div>

      <div id="errorListSection" class="mt-3" style="display:none;">
        <h6 class="mb-2 text-secondary">Revisão (lista original de erradas)</h6>
        <textarea id="errorListArea" class="form-control" rows="4" readonly></textarea>
      </div>

      <div class="mt-3 text-muted small keyboard-hint">
        Dica: use ← e → para navegar; pressione <span class="fw-bold">↓</span> para marcar a palavra atual como errada (quando o registro estiver ativo). Pressione <span class="fw-bold">↑</span> para repetir a palavra.
      </div>
    </div>
  </div>

  <!-- Offcanvas / painel de OPÇÕES -->
  <div class="offcanvas offcanvas-end" tabindex="-1" id="configOffcanvas" aria-labelledby="configOffcanvasLabel">
    <div class="offcanvas-header">
      <h5 class="offcanvas-title" id="configOffcanvasLabel"><i class="bi bi-gear-fill me-2"></i>Opções</h5>
      <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Fechar"></button>
    </div>

    <div class="offcanvas-body">
      <!-- Timer (com ícone) -->
      <div class="mb-3 d-flex align-items-start justify-content-between">
        <div>
          <h6 class="mb-1"><i class="bi bi-clock-history me-2"></i>Timer</h6>
        </div>
        <button class="help-btn" data-bs-toggle="modal" data-bs-target="#helpTimerModal" title="Ajuda Timer">?</button>
      </div>
      <div class="d-flex align-items-center gap-2 mb-3">
        <button id="autoBtn" class="btn btn-outline-success btn-sm">Automático</button>
      </div>

      <hr>

      <!-- Ditado de Erradas (com ícone removido no botão) -->
      <div class="mb-3 d-flex align-items-start justify-content-between">
        <div>
          <h6 class="mb-1"><i class="bi bi-exclamation-triangle me-2"></i>Ditado de Erradas</h6>
        </div>
        <button class="help-btn" data-bs-toggle="modal" data-bs-target="#helpErradasModal" title="Ajuda Erradas">?</button>
      </div>
      <div class="d-flex gap-2 mb-3">
        <button id="toggleErrorBtn" class="btn btn-outline-danger btn-sm">Registrar Erradas (↓)</button>
      </div>

      <hr>

      <!-- Narrador -->
      <div class="mb-3 d-flex align-items-start justify-content-between">
        <div>
          <h6 class="mb-1"><i class="bi bi-volume-up me-2"></i>Narrador</h6>
        </div>
        <button class="help-btn" data-bs-toggle="modal" data-bs-target="#helpNarradorModal" title="Ajuda Narrador">?</button>
      </div>

      <div class="d-flex flex-column gap-2 mb-2">
        <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" id="narratorToggle" checked>
          <label class="form-check-label" for="narratorToggle">Narrador (ativado)</label>
        </div>

        <div class="form-check form-switch">
          <input class="form-check-input" type="checkbox" id="announceNextToggle" checked>
          <label class="form-check-label" for="announceNextToggle">Falar "Próxima palavra" (ativado)</label>
        </div>

        <button id="unlockAudioBtn" class="btn btn-info btn-sm d-none" title="Destravar áudio"><i class="bi bi-volume-up me-1"></i> Tocar áudio (ativar voz)</button>
      </div>
    </div>
  </div>

  <!-- HELP MODALS (mantidos) -->
  <div class="modal fade" id="helpTimerModal" tabindex="-1" aria-labelledby="helpTimerModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="helpTimerModalLabel"><i class="bi bi-clock-history me-2"></i>Sobre o Timer</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
        </div>
        <div class="modal-body">
          <p>Ao ativar <strong>Automático</strong> aqui, os controles do timer aparecem na tela principal (intervalo e botão “Iniciar Timer”).</p>
          <ul>
            <li>É necessário primeiro iniciar o ditado com <strong>Iniciar</strong> (botão acima da lista). Depois, clique em <strong>Iniciar Timer</strong> para disparar o cronômetro automático.</li>
            <li>Se nenhuma palavra estiver carregada, o sistema solicitará que você carregue palavras antes do início.</li>
            <li>Use <em>Pausar</em> para interromper a contagem e <em>Retomar</em> para continuar (aparecerá apenas quando o timer tiver sido iniciado).</li>
          </ul>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="helpErradasModal" tabindex="-1" aria-labelledby="helpErradasModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="helpErradasModalLabel"><i class="bi bi-exclamation-triangle me-2"></i>Sobre Ditado de Erradas</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
        </div>
        <div class="modal-body">
          <p>Quando <strong>Registrar Erradas</strong> está ativado, você pode marcar palavras que errar e revisá-las depois.</p>
          <ul>
            <li>Use a tecla <strong>↓ (seta para baixo)</strong> para marcar a palavra atual como errada quando o registro estiver ativo.</li>
            <li>Ao finalizar a revisão de erradas, aparecerá o botão <strong>Refazer Erradas</strong> — ele remove as gerações filhas da geração revisada (ou seja, exclui as palavras geradas a partir dela) e permite refazer a revisão dessa geração.</li>
            <li>O botão <strong>Ditado Erradas</strong> prepara e inicia a revisão da última lista de erradas disponível.</li>
          </ul>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
        </div>
      </div>
    </div>
  </div>

  <div class="modal fade" id="helpNarradorModal" tabindex="-1" aria-labelledby="helpNarradorModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-dialog-centered">
      <div class="modal-content">
        <div class="modal-header">
          <h5 class="modal-title" id="helpNarradorModalLabel"><i class="bi bi-volume-up me-2"></i>Sobre o Narrador</h5>
          <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Fechar"></button>
        </div>
        <div class="modal-body">
          <p>As opções do narrador permitem controlar a leitura das palavras e anúncios:</p>
          <ul>
            <li><strong>Narrador</strong>: ativa/desativa a leitura das palavras; também controla o botão Repetir.</li>
            <li><strong>Falar "Próxima palavra"</strong>: controla apenas a frase anunciada antes do avanço; se ativado, o anúncio será executado mesmo que o Narrador esteja desativado.</li>
          </ul>
        </div>
        <div class="modal-footer">
          <button class="btn btn-secondary" data-bs-dismiss="modal">Fechar</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" defer></script>

  <!-- SCRIPT principal (único arquivo) -->
  <script defer>
    // === Elementos principais ===
    const loadBtn = document.getElementById('loadBtn');
    const startBtn = document.getElementById('startBtn');
    const shuffleBtn = document.getElementById('shuffleBtn');
    const prevBtn = document.getElementById('prevBtn');
    const nextBtn = document.getElementById('nextBtn');
    const repeatBtn = document.getElementById('repeatBtn');

    const autoBtn = document.getElementById('autoBtn');
    const toggleErrorBtn = document.getElementById('toggleErrorBtn');

    // proxies timer
    const startTimerProxy = document.getElementById('startTimerProxy');
    const pauseProxy = document.getElementById('pauseProxy');
    const intervalInputProxy = document.getElementById('intervalInputProxy');

    // proxies erradas (agora abaixo do timer)
    const addWrongProxy = document.getElementById('addWrongProxy');
    const startErrorProxy = document.getElementById('startErrorProxy');
    const redoWrongProxy = document.getElementById('redoWrongProxy');
    const launchErrorProxy = document.getElementById('launchErrorProxy');
    const clearErrorProxy = document.getElementById('clearErrorProxy');

    const inactiveClock = document.getElementById('inactiveClock');
    const progressCircle = document.getElementById('progressCircle');
    const centerSeconds = document.getElementById('centerSeconds');

    const narratorToggle = document.getElementById('narratorToggle');
    const announceNextToggle = document.getElementById('announceNextToggle');

    const wordListEl = document.getElementById('wordList');
    const currentWordEl = document.getElementById('currentWord');
    const timerDisplay = document.getElementById('timerDisplay');
    const statusEl = document.getElementById('status');
    const wrongSection = document.getElementById('wrongSection');
    const wrongWordsList = document.getElementById('wrongWordsList');
    const errorListSection = document.getElementById('errorListSection');
    const errorListArea = document.getElementById('errorListArea');
    const totalCountDisplay = document.getElementById('totalCountDisplay');

    // Estado básico
    let words = [];
    let index = 0;
    let errorMode = false;

    // Gestão de erradas com gerações
    let wrongGenerations = [];                // array de arrays (G0, G1, ...)
    let currentMarkedWrongWords = [];        // marcas feitas fora de revisão (mostradas em Palavras Erradas)
    let reviewMarkedWrongWords = [];         // marcas durante revisão (serão geração filha)
    let currentGenerationIndex = -1;         // geração em revisão (pai) -> index em wrongGenerations
    let lastReviewedGenerationIndex = -1;    // última geração finalizada
    let isReviewMode = false;
    let canShowRedo = false;

    let lastLoadedMain = 0;
    let lastLoadedWrong = 0;

    // timing/timer
    let ringRaf = null;
    let ringStartTime = null;
    let ringDuration = null;
    let endTimer = null;
    let tickInterval = null;

    let remainingSec = 0;
    let isAuto = false;
    let isPaused = false;
    let awaitingAnnouncement = false;
    let pendingLaunch = false;
    let autoArmed = false;

    let dictationRunning = false;

    // narrator flags
    let narratorEnabled = !!(narratorToggle && narratorToggle.checked);
    let announceNextEnabled = !!(announceNextToggle && announceNextToggle.checked);

    let audioUnlocked = false;

    const R = 44;
    const CIRC = 2 * Math.PI * R;
    if (progressCircle) {
      progressCircle.style.strokeDasharray = `${CIRC}`;
      progressCircle.style.strokeDashoffset = `0`;
    }

    const startColor = { r: 16, g: 185, b: 129 };
    const endColor = { r: 220, g: 38, b: 38 };

    function lerp(a,b,t){ return Math.round(a + (b-a)*t); }
    function colorLerp(c1,c2,t){ return `rgb(${lerp(c1.r,c2.r,t)}, ${lerp(c1.g,c2.g,t)}, ${lerp(c1.b,c2.b,t)})`; }

    function speakWithPromise(text, { interrupt = true, fallbackMs = 1200, allowWhenNarratorOff = false } = {}) {
      return new Promise((resolve) => {
        if (!narratorEnabled && !allowWhenNarratorOff) { resolve(); return; }
        try { if (interrupt) speechSynthesis.cancel(); } catch(e){}
        const u = new SpeechSynthesisUtterance(text); u.lang = 'pt-BR';
        let resolved = false;
        u.onend = () => { if (!resolved) { resolved = true; resolve(); } };
        u.onerror = () => { if (!resolved) { resolved = true; resolve(); } };
        const guard = setTimeout(() => { if (!resolved) { resolved = true; resolve(); } }, fallbackMs + 400);
        const originalResolve = resolve;
        resolve = () => { clearTimeout(guard); originalResolve(); };
        try { speechSynthesis.speak(u); } catch(e) { resolve(); }
      });
    }

    // Visual helpers
    function showInactiveClock() {
      if (!inactiveClock) return;
      inactiveClock.classList.remove('hidden');
      inactiveClock.classList.add('visible');
      const svg = document.getElementById('countdownSvg');
      if (svg) svg.style.display = 'none';
      if (centerSeconds) centerSeconds.textContent = '-';
      if (progressCircle) {
        progressCircle.style.strokeDashoffset = '0';
        progressCircle.style.stroke = colorLerp(startColor,endColor,0);
      }
    }
    function hideInactiveClock() {
      if (!inactiveClock) return;
      inactiveClock.classList.remove('visible');
      inactiveClock.classList.add('hidden');
      const svg = document.getElementById('countdownSvg');
      if (svg) svg.style.display = 'block';
    }
    function animateClockToRingThenStart(callback) {
      if (!inactiveClock) return;
      inactiveClock.classList.remove('visible');
      inactiveClock.classList.remove('hidden');
      inactiveClock.classList.add('anim-to-ring');
      setTimeout(() => {
        inactiveClock.classList.add('hidden');
        inactiveClock.classList.remove('anim-to-ring');
        const svg = document.getElementById('countdownSvg');
        if (svg) svg.style.display = 'block';
        if (progressCircle) {
          progressCircle.style.stroke = colorLerp(startColor, endColor, 0);
          progressCircle.classList.add('progress-transition');
        }
        if (typeof callback === 'function') callback();
      }, 520);
    }

    function setAutoArmedVisual(on){
      if(!autoBtn) return;
      if(on){ autoBtn.classList.remove('btn-outline-success'); autoBtn.classList.add('btn-success','pulse'); }
      else { autoBtn.classList.remove('btn-success','pulse'); autoBtn.classList.add('btn-outline-success'); }
      if(on) showMainTimerProxies(); else hideMainTimerProxies();
      if(!on) statusEl.textContent = 'Timer Desativado'; else statusEl.textContent = 'Timer Pronto';
    }
    function setAutoRunningVisual(on){
      if(!autoBtn) return;
      if(on){ autoBtn.classList.remove('btn-outline-success'); autoBtn.classList.add('btn-success','pulse'); }
      else { autoBtn.classList.remove('btn-success','pulse'); autoBtn.classList.add('btn-outline-success'); }
    }
    function setPauseVisual(paused){
      if(!pauseProxy) return;
      if(paused){ pauseProxy.classList.remove('btn-outline-warning'); pauseProxy.classList.add('btn-warning','active'); pauseProxy.innerHTML = '<i class="bi bi-play-fill me-1"></i> Retomar'; }
      else { pauseProxy.classList.remove('btn-warning','active'); pauseProxy.classList.add('btn-outline-warning'); pauseProxy.innerHTML = '<i class="bi bi-pause-fill me-1"></i> Pausar'; }
    }

    function setErrorToggleVisual(on){
      if(!toggleErrorBtn) return;
      if(on){ toggleErrorBtn.classList.remove('btn-outline-danger'); toggleErrorBtn.classList.add('btn-danger','btn-err-active'); toggleErrorBtn.textContent = 'Registro Ativo'; }
      else { toggleErrorBtn.classList.remove('btn-danger','btn-err-active'); toggleErrorBtn.classList.add('btn-outline-danger'); toggleErrorBtn.textContent = 'Registrar Erradas (↓)'; }
      if(on) showMainErrorProxies(); else hideMainErrorProxies();
    }

    function clearCountdown(){
      if(endTimer){ clearTimeout(endTimer); endTimer=null; }
      if(tickInterval){ clearInterval(tickInterval); tickInterval=null; }
      if(ringRaf){ cancelAnimationFrame(ringRaf); ringRaf=null; }
      ringStartTime=null; ringDuration=null;
      if (progressCircle) {
        progressCircle.style.transition = 'stroke-dashoffset 240ms linear, stroke 240ms linear';
        progressCircle.style.strokeDashoffset = '0';
        progressCircle.style.stroke = colorLerp(startColor, endColor, 0);
      }
      if (centerSeconds) centerSeconds.textContent='-';
      if (timerDisplay) timerDisplay.textContent='';
    }

    function setCountdownFor(sec){
      if(pendingLaunch){ clearCountdown(); return; }
      clearCountdown();
      remainingSec = Math.max(1, Math.floor(sec) || 1);
      ringDuration = remainingSec * 1000;
      ringStartTime = performance.now();
      if (progressCircle) progressCircle.style.transition='none';
      if (progressCircle) progressCircle.style.stroke = colorLerp(startColor, endColor, 0);
      updateCenterSeconds(remainingSec);
      if (timerDisplay) timerDisplay.textContent = `Próxima em: ${remainingSec}s`;
      endTimer = setTimeout(()=>{ clearCountdown(); announceThenAdvance(); }, ringDuration);
      tickInterval = setInterval(()=>{
        if(isPaused) return;
        const elapsedMs = performance.now() - ringStartTime;
        const remMs = Math.max(0, ringDuration - elapsedMs);
        const rem = Math.ceil(remMs / 1000);
        updateCenterSeconds(rem);
        if (timerDisplay) timerDisplay.textContent = `Próxima em: ${rem}s`;
      },150);
      function step(now){
        if(!ringStartTime || isPaused){ ringRaf = requestAnimationFrame(step); return; }
        const elapsedMs = now - ringStartTime;
        const progress = Math.min(1, elapsedMs / ringDuration);
        const offset = progress * CIRC;
        if (progressCircle) {
          progressCircle.style.strokeDashoffset = `${offset}`;
          progressCircle.style.stroke = colorLerp(startColor, endColor, progress);
        }
        if (progress < 1) ringRaf = requestAnimationFrame(step);
        else { if (progressCircle) { progressCircle.style.strokeDashoffset = `${CIRC}`; progressCircle.style.stroke = colorLerp(startColor,endColor,1); } }
      }
      ringRaf = requestAnimationFrame(step);
    }

    function updateCenterSeconds(n){ if (centerSeconds) centerSeconds.textContent = `${n}s`; }

    function speakAndShow(text){
      if (currentWordEl) currentWordEl.textContent = text;
      if (!narratorEnabled) return;
      try { speechSynthesis.cancel(); } catch(e){}
      const u = new SpeechSynthesisUtterance(text); u.lang='pt-BR';
      speechSynthesis.speak(u);
    }

    async function announceThenAdvance(){
      if(awaitingAnnouncement) return;
      if(pendingLaunch){ awaitingAnnouncement=false; return; }
      awaitingAnnouncement = true;
      try {
        try{ speechSynthesis.cancel(); } catch(e){}
        if (announceNextEnabled) {
          await speakWithPromise('Próxima palavra', { interrupt:true, fallbackMs:900, allowWhenNarratorOff:true });
        }
      } catch(e){}
      finally {
        awaitingAnnouncement = false;
        if(!isPaused && !pendingLaunch) advanceDictation();
        else if (timerDisplay) timerDisplay.textContent='';
      }
    }

    // dictation flow
    function beginDictation(){
      dictationRunning = true; index = 0; awaitingAnnouncement = false;
      if (words[index]) speakAndShow(words[index]);
      nextBtn.disabled = false; startBtn.disabled = true;
      // garantir pause oculto no início do ditado
      isPaused = false;
      setPauseVisual(false);
      if (pauseProxy) pauseProxy.classList.add('hidden');
      if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
    }

    function advanceDictation(fromManual=false){
      index++;
      if(index < words.length){
        speakAndShow(words[index]);
        if (prevBtn) prevBtn.disabled = false;
        if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
      } else finishDictation();
    }

    function finishDictation(){
      dictationRunning = false;
      clearCountdown();

      // Estatísticas
      let total = 0;
      let wrongCount = 0;
      if (isReviewMode) {
        total = lastLoadedWrong || words.length;
        wrongCount = reviewMarkedWrongWords.length;
      } else {
        total = lastLoadedMain || words.length;
        wrongCount = currentMarkedWrongWords.length;
      }
      let accuracy = 0;
      if (total > 0) accuracy = Math.round(((total - wrongCount) / total) * 1000) / 10;

      if (isReviewMode) {
        alert('Revisão concluída!');
        statusEl.textContent = `Revisão concluída — total: ${total} | erradas geradas: ${wrongCount} | acerto: ${accuracy}%`;
      } else {
        alert('Ditado concluído!');
        statusEl.textContent = `Lista concluída — total: ${total} | erradas: ${wrongCount} | acerto: ${accuracy}%`;
      }

      // ao finalizar revisão: converter reviewMarkedWrongWords em geração filha
      if (isReviewMode) {
        if (reviewMarkedWrongWords.length > 0) {
          wrongGenerations.push(reviewMarkedWrongWords.slice());
          lastLoadedWrong = reviewMarkedWrongWords.length;
          // mostrar as palavras geradas pela revisão no bloco "Palavras Erradas"
          currentMarkedWrongWords = wrongGenerations[wrongGenerations.length - 1].slice();
        }
        // manter a lista de revisão (pai) visível para o usuário
        lastReviewedGenerationIndex = currentGenerationIndex;
        canShowRedo = lastReviewedGenerationIndex >= 0;
        if (errorListSection) {
          errorListSection.style.display = 'block';
          // mantemos o textarea exibindo a lista pai (geração que foi revisada)
          if (errorListArea && currentGenerationIndex >=0 && wrongGenerations[currentGenerationIndex]) {
            errorListArea.value = wrongGenerations[currentGenerationIndex].join('\n');
          } else if (errorListArea) {
            // fallback — se não houver pai registrado, manter textarea com a última lista usada
            errorListArea.value = wrongGenerations[wrongGenerations.length - 2] ? wrongGenerations[wrongGenerations.length - 2].join('\n') : '';
          }
        }
        // limpa marcas de revisão (já gravadas)
        reviewMarkedWrongWords = [];
        isReviewMode = false;
      } else {
        // finalização da lista principal
        if (currentMarkedWrongWords.length > 0) {
          wrongGenerations.push(currentMarkedWrongWords.slice());
          lastLoadedWrong = currentMarkedWrongWords.length;
          // exibir as erradas geradas da lista principal
          // (mantemos currentMarkedWrongWords como está)
        }
        canShowRedo = false;
      }

      // UI e flags
      if (currentWordEl) currentWordEl.textContent='';
      if (nextBtn) nextBtn.disabled=true;
      if (prevBtn) prevBtn.disabled=true;
      if (startBtn) startBtn.disabled=false;
      if (shuffleBtn) shuffleBtn.disabled=false;
      isAuto = false; isPaused = false; pendingLaunch = false;
      if (autoArmed) showStartTimerProxy(); else hideMainTimerProxies();

      // mostrar controles de erradas se aplicável (e manter o bloco de erradas exibindo as palavras)
      if (errorMode || (currentMarkedWrongWords && currentMarkedWrongWords.length > 0) || (wrongGenerations && wrongGenerations.length > 0)) {
        showMainErrorProxies();
      } else {
        hideMainErrorProxies();
      }

      showInactiveClock();
      renderWrongWords();
    }

    function pauseAuto(){
      if(!isAuto || isPaused) return;
      isPaused = true;
      if(ringStartTime && ringDuration){
        const elapsedMs = performance.now() - ringStartTime;
        const remMs = Math.max(0, ringDuration - elapsedMs);
        remainingSec = Math.max(0, Math.ceil(remMs / 1000));
      } else remainingSec = Math.max(1, remainingSec || 1);
      clearCountdown();
      try { speechSynthesis.cancel(); } catch(e){}
      awaitingAnnouncement = false;
      if (statusEl) statusEl.textContent = `Automático pausado. ${remainingSec}s restantes.`;
      setPauseVisual(true);
    }

    function resumeAuto(){
      if(!isAuto || !isPaused) return;
      isPaused = false;
      setPauseVisual(false);
      if (statusEl) statusEl.textContent = 'Automático retomado.';
      try { speechSynthesis.cancel(); } catch(e){}
      if (words[index]) speakAndShow(words[index]);
      const secToUse = Math.max(1, remainingSec || 1);
      if(!pendingLaunch) setCountdownFor(secToUse); else clearCountdown();
    }

    // proxies visibility
    function showMainTimerProxies(){
      const area = document.getElementById('mainTimerProxies');
      if (!area) return;
      area.classList.remove('hidden'); area.setAttribute('aria-hidden','false');
      showStartTimerProxy();
    }
    function hideMainTimerProxies(){
      const area = document.getElementById('mainTimerProxies');
      if (!area) return;
      area.classList.add('hidden'); area.setAttribute('aria-hidden','true');
      if (startTimerProxy) startTimerProxy.classList.add('hidden');
      if (pauseProxy) pauseProxy.classList.add('hidden');
    }
    function showStartTimerProxy(){
      if (!startTimerProxy) return;
      startTimerProxy.classList.remove('hidden');
      if (pauseProxy) pauseProxy.classList.add('hidden');
    }
    function hideStartTimerProxy(){
      if (startTimerProxy) startTimerProxy.classList.add('hidden');
      if(isAuto && pauseProxy) pauseProxy.classList.remove('hidden'); else if (pauseProxy) pauseProxy.classList.add('hidden');
    }

    function showMainErrorProxies(){
      const area = document.getElementById('mainErrorProxies');
      if (!area) return;
      area.classList.remove('hidden'); area.setAttribute('aria-hidden','false');
      if (addWrongProxy) addWrongProxy.classList.remove('hidden');
      if (startErrorProxy) startErrorProxy.classList.remove('hidden');
      if (clearErrorProxy) clearErrorProxy.classList.remove('hidden');

      // Refazer Erradas só se canShowRedo === true e não estivermos em revisão
      if (redoWrongProxy) {
        if (canShowRedo && !isReviewMode) {
          redoWrongProxy.classList.remove('hidden');
          redoWrongProxy.classList.add('redo-appear');
          setTimeout(()=>{ if (redoWrongProxy) redoWrongProxy.classList.remove('redo-appear'); }, 700);
        } else {
          redoWrongProxy.classList.add('hidden');
          redoWrongProxy.classList.remove('redo-appear');
        }
      }

      if(pendingLaunch && launchErrorProxy) launchErrorProxy.classList.remove('hidden'); else if (launchErrorProxy) launchErrorProxy.classList.add('hidden');
    }
    function hideMainErrorProxies(){
      const area = document.getElementById('mainErrorProxies');
      if (!area) return;
      area.classList.add('hidden'); area.setAttribute('aria-hidden','true');
      if (addWrongProxy) addWrongProxy.classList.add('hidden');
      if (startErrorProxy) startErrorProxy.classList.add('hidden');
      if (launchErrorProxy) launchErrorProxy.classList.add('hidden');
      if (clearErrorProxy) clearErrorProxy.classList.add('hidden');
      if (redoWrongProxy) { redoWrongProxy.classList.add('hidden'); redoWrongProxy.classList.remove('redo-appear'); }
    }

    // Render errado UI
    function renderWrongWords(){
      // Mostrar as erradas apropriadas: se estivermos em revisão, mostramos reviewMarkedWrongWords,
      // caso contrário mostramos currentMarkedWrongWords (que também recebe as gerações finais).
      const arr = isReviewMode ? reviewMarkedWrongWords : currentMarkedWrongWords;
      wrongWordsList.innerHTML = (arr||[]).map(w => `<span class="chip" role="button" tabindex="0">${w} <i class="bi bi-x-lg ms-1"></i></span>`).join('');
      startErrorProxy.disabled = !((currentMarkedWrongWords && currentMarkedWrongWords.length) || (wrongGenerations && wrongGenerations.length));
      clearErrorProxy.disabled = !((currentMarkedWrongWords && currentMarkedWrongWords.length) || (wrongGenerations && wrongGenerations.length));
      wrongSection.style.display = ( (arr && arr.length>0) || errorMode ) ? 'block' : 'none';
    }

    // === Eventos e comportamentos principais ===
    (function attachListeners(){
      // Auto (menu)
      if (autoBtn) autoBtn.addEventListener('click', () => {
        autoArmed = !autoArmed;
        setAutoArmedVisual(autoArmed);
        if (autoArmed) {
          if (statusEl) statusEl.textContent = 'Timer Pronto';
          showInactiveClock();
        } else {
          if (statusEl) statusEl.textContent = 'Timer Desativado';
          if (isAuto) { isAuto=false; isPaused=false; clearCountdown(); }
          showInactiveClock();
        }
      });

      // iniciar timer proxy
      if (startTimerProxy) startTimerProxy.addEventListener('click', () => {
        if (!autoArmed) { if (statusEl) statusEl.textContent = 'Ative Automático no menu de Opções primeiro.'; return; }
        if (!words || words.length === 0) { if (statusEl) statusEl.textContent = 'Carregue palavras antes de iniciar o timer.'; return; }
        if (!dictationRunning) { if (statusEl) statusEl.textContent = 'Inicie o ditado (botão "Iniciar") antes de ativar o timer.'; return; }

        isAuto = true; isPaused = false;
        setAutoRunningVisual(true);
        if (statusEl) statusEl.textContent = 'Timer iniciado.';
        hideStartTimerProxy();
        if (pauseProxy) pauseProxy.classList.remove('hidden');

        animateClockToRingThenStart(() => {
          setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
        });
      });

      // pause proxy
      if (pauseProxy) pauseProxy.addEventListener('click', () => { if(!isAuto) return; if(isPaused) resumeAuto(); else pauseAuto(); });

      // interval change
      if (intervalInputProxy) intervalInputProxy.addEventListener('change', (e) => { if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10))); });

      // add wrong
      if (addWrongProxy) addWrongProxy.addEventListener('click', () => {
        const cur = currentWordEl && currentWordEl.textContent ? currentWordEl.textContent.trim() : '';
        if (!cur) return;
        if (!errorMode) return;
        if (isReviewMode) {
          if (!reviewMarkedWrongWords.includes(cur)) {
            reviewMarkedWrongWords.push(cur);
            statusEl.textContent = `"${cur}" adicionada às erradas (revisão).`;
          }
        } else {
          if (!currentMarkedWrongWords.includes(cur)) {
            currentMarkedWrongWords.push(cur);
            statusEl.textContent = `"${cur}" adicionada às erradas.`;
          }
        }
        renderWrongWords();
      });

      // startErrorProxy: prepara a revisão a partir das erradas atuais
      if (startErrorProxy) startErrorProxy.addEventListener('click', () => {
        // prioriza marcas da sessão principal
        let listToUse = (currentMarkedWrongWords && currentMarkedWrongWords.length) ? currentMarkedWrongWords.slice() : [];
        if (!listToUse.length && wrongGenerations.length) listToUse = wrongGenerations[wrongGenerations.length - 1].slice();
        if (!listToUse.length) return alert('Não há palavras erradas para iniciar a revisão.');
        // registrar essa geração como pai (se desejar)
        wrongGenerations.push(listToUse.slice());
        currentGenerationIndex = wrongGenerations.length - 1;
        // bloqueia redo enquanto preparamos/iniciamos
        canShowRedo = false;
        if (redoWrongProxy) { redoWrongProxy.classList.add('hidden'); redoWrongProxy.classList.remove('redo-appear'); }

        // preparar revisão
        lastLoadedWrong = listToUse.length;
        words = [...listToUse];
        index = 0;
        statusEl.textContent = 'Preparado: pronto para iniciar revisão das erradas.';
        pendingLaunch = true;
        try{ speechSynthesis.cancel(); }catch(e){}
        clearCountdown(); awaitingAnnouncement = false;
        if (launchErrorProxy) launchErrorProxy.classList.remove('hidden');
        // limpar marcas fora de revisão (já salvas na geração)
        currentMarkedWrongWords = [];
        // exibir a área de revisão (lista pai)
        if (errorListSection) { errorListSection.style.display = 'block'; if (errorListArea) errorListArea.value = wrongGenerations[currentGenerationIndex].join('\n'); }
        renderWrongWords();
      });

      // launchErrorProxy: inicia a revisão
      if (launchErrorProxy) launchErrorProxy.addEventListener('click', () => {
        // esconde redo quando revisar
        canShowRedo = false;
        if (redoWrongProxy) { redoWrongProxy.classList.add('hidden'); redoWrongProxy.classList.remove('redo-appear'); }

        launchErrorProxy.classList.add('hidden');
        index = 0;
        statusEl.textContent = 'Ditado de erradas iniciado.';
        pendingLaunch = false;
        if (prevBtn) prevBtn.disabled = false;
        if (errorListSection) errorListSection.style.display = 'block';
        if (errorListArea && currentGenerationIndex >=0) errorListArea.value = wrongGenerations[currentGenerationIndex].join('\n');
        reviewMarkedWrongWords = [];
        isReviewMode = true;
        renderWrongWords();
        beginDictation();
        if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
      });

      // clear error proxy: apaga tudo (gerações e marcas)
      if (clearErrorProxy) clearErrorProxy.addEventListener('click', () => {
        currentMarkedWrongWords = []; wrongGenerations = []; reviewMarkedWrongWords = [];
        currentGenerationIndex = -1; lastReviewedGenerationIndex = -1; lastLoadedWrong = 0;
        renderWrongWords();
        if (errorListSection) errorListSection.style.display = 'none';
        if (wrongSection) wrongSection.style.display = 'none';
        pendingLaunch = false; if (launchErrorProxy) launchErrorProxy.classList.add('hidden'); hideMainErrorProxies();
        canShowRedo = false;
      });

      // redoWrongProxy: refazer a geração revisada (deleta as gerações filhas)
      if (redoWrongProxy) redoWrongProxy.addEventListener('click', () => {
        if (lastReviewedGenerationIndex < 0) return alert('Nenhuma revisão finalizada para refazer.');
        // remover gerações filhas
        if (wrongGenerations.length > lastReviewedGenerationIndex + 1) {
          wrongGenerations.splice(lastReviewedGenerationIndex + 1);
        }
        // reabrir revisão da geração
        currentGenerationIndex = lastReviewedGenerationIndex;
        words = (wrongGenerations[currentGenerationIndex] || []).slice();
        // reset marcas advindas das filhas (foram excluídas)
        reviewMarkedWrongWords = [];
        isReviewMode = true;
        canShowRedo = false;
        index = 0;
        statusEl.textContent = 'Refazendo erradas: lista resetada. Revisão iniciada.';
        if (errorListSection) errorListSection.style.display = 'block';
        if (errorListArea) errorListArea.value = words.join('\n');
        try{ speechSynthesis.cancel(); }catch(e){}
        beginDictation();
        if(isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
        renderWrongWords();
      });

      // load list principal
      if (loadBtn) loadBtn.addEventListener('click', () => {
        const raw = (wordListEl && wordListEl.value || '').trim();
        if(!raw) return alert('Insira ao menos uma palavra.');
        words = raw.split(/\r?\n/).map(w => w.trim()).filter(Boolean);
        index = 0; isAuto = false; isPaused = false;
        currentMarkedWrongWords = []; reviewMarkedWrongWords = []; wrongGenerations = [];
        currentGenerationIndex = -1; lastReviewedGenerationIndex = -1;
        if (startBtn) startBtn.disabled = false;
        if (shuffleBtn) shuffleBtn.disabled = false;
        if (prevBtn) prevBtn.disabled = true;
        if (nextBtn) nextBtn.disabled = true;
        if (currentWordEl) currentWordEl.textContent = '';
        clearCountdown();
        lastLoadedMain = words.length;
        if (totalCountDisplay) totalCountDisplay.textContent = `Carregadas: ${lastLoadedMain}`;
        statusEl.textContent = `Lista carregada: ${words.length} palavras.`;
        if (wrongSection) wrongSection.style.display = 'none';
        if (errorListSection) errorListSection.style.display = 'none';
        renderWrongWords();
        pendingLaunch = false;
        setPauseVisual(false);
        if (pauseProxy) pauseProxy.classList.add('hidden');
        if (autoArmed) { showStartTimerProxy(); showInactiveClock(); } else { hideMainTimerProxies(); showInactiveClock(); }
        // reset completo do fluxo de revisão/redo — garantir que nada permaneça ativo
        currentMarkedWrongWords = [];
        reviewMarkedWrongWords = [];
        wrongGenerations = [];
        currentGenerationIndex = -1;
        lastReviewedGenerationIndex = -1;
        lastLoadedWrong = 0;
        canShowRedo = false;
        // forçar esconder do botão redo
        if (redoWrongProxy) { redoWrongProxy.classList.add('hidden'); redoWrongProxy.classList.remove('redo-appear'); }
        // esconder area de revisão
        if (errorListSection) errorListSection.style.display = 'none';
        if (wrongSection) wrongSection.style.display = 'none';
      });

      // shuffle
      if (shuffleBtn) shuffleBtn.addEventListener('click', () => {
        for (let i = words.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [words[i], words[j]] = [words[j], words[i]];
        }
        index = 0;
        if (statusEl) statusEl.textContent = 'Lista embaralhada.';
        renderWrongWords();
      });

      // start ditado principal (com aviso se houver revisões/erradas)
      if (startBtn) startBtn.addEventListener('click', () => {
        if(!words.length) return;
        // se houver revisões em andamento / gerações / marcas, avisar que iremos reiniciar tudo
        if (isReviewMode || pendingLaunch || (wrongGenerations && wrongGenerations.length > 0) || (currentMarkedWrongWords && currentMarkedWrongWords.length > 0)) {
          const ok = confirm('Ao iniciar a lista principal todas as revisões/erradas em andamento serão reiniciadas. Deseja continuar?');
          if (!ok) return;
          // reset completo das revisões/erradas
          currentMarkedWrongWords = [];
          reviewMarkedWrongWords = [];
          wrongGenerations = [];
          currentGenerationIndex = -1;
          lastReviewedGenerationIndex = -1;
          lastLoadedWrong = 0;
          canShowRedo = false;
          pendingLaunch = false;
          if (errorListSection) errorListSection.style.display = 'none';
          if (wrongSection) wrongSection.style.display = 'none';
          hideMainErrorProxies();
          // garantir que botão redo escondido
          if (redoWrongProxy) { redoWrongProxy.classList.add('hidden'); redoWrongProxy.classList.remove('redo-appear'); }
        }
        // iniciar lista principal
        if (wrongSection) wrongSection.style.display='none';
        if (errorListSection) errorListSection.style.display='none';
        isReviewMode = false;
        canShowRedo = false;
        beginDictation();
        if (shuffleBtn) shuffleBtn.disabled = true;
        if (prevBtn) prevBtn.disabled = false;
        setPauseVisual(false);
        if (pauseProxy) pauseProxy.classList.add('hidden');
        if (autoArmed) showStartTimerProxy();
      });

      // toggle registrar erradas
      if (toggleErrorBtn) toggleErrorBtn.addEventListener('click', () => {
        errorMode = !errorMode;
        setErrorToggleVisual(errorMode);
        statusEl.textContent = errorMode ? 'Registro de erros ativado.' : 'Registro de erros desativado.';
      });

      // prev
      if (prevBtn) prevBtn.addEventListener('click', () => {
        if (index > 0) {
          index--;
          if (words[index]) speakAndShow(words[index]);
          if (nextBtn) nextBtn.disabled = false;
          if (isAuto && !isPaused && !pendingLaunch) setCountdownFor(Math.max(1, parseInt(intervalInputProxy.value || 3,10)));
        }
        if (index === 0 && prevBtn) prevBtn.disabled = true;
      });

      // next
      if (nextBtn) nextBtn.addEventListener('click', () => { clearCountdown(); advanceDictation(true); });

      // repeat
      if (repeatBtn) repeatBtn.addEventListener('click', () => {
        if (!words.length || !currentWordEl.textContent) return;
        if (narratorEnabled) {
          repeatBtn.classList.add('btn-rotate');
          try{ speechSynthesis.cancel(); }catch(e){}
          const u=new SpeechSynthesisUtterance(words[index]); u.lang='pt-BR';
          u.onend=()=>{ repeatBtn.classList.remove('btn-rotate'); };
          speechSynthesis.speak(u);
          setTimeout(()=>repeatBtn.classList.remove('btn-rotate'),1200);
        }
      });

      // keyboard shortcuts (inclui marcação por ArrowDown)
      document.addEventListener('keydown', (e) => {
        const active = document.activeElement && document.activeElement.tagName ? document.activeElement.tagName.toLowerCase() : '';
        if(active === 'input' || active === 'textarea') return;
        if(e.key === 'ArrowUp'){ e.preventDefault(); if(!repeatBtn.disabled) repeatBtn.click(); return; }

        if(errorMode && e.key === 'ArrowDown' && currentWordEl && currentWordEl.textContent){
          e.preventDefault();
          const w = currentWordEl.textContent.trim();
          if (!w) return;
          if (isReviewMode) {
            if (!reviewMarkedWrongWords.includes(w)) { reviewMarkedWrongWords.push(w); statusEl.textContent = `"${w}" adicionada às erradas (revisão).`; }
          } else {
            if (!currentMarkedWrongWords.includes(w)) { currentMarkedWrongWords.push(w); statusEl.textContent = `"${w}" adicionada às erradas.`; }
          }
          renderWrongWords();
          return;
        }

        if(e.key === 'ArrowRight'){ e.preventDefault(); if(!nextBtn.disabled) nextBtn.click(); } else if(e.key === 'ArrowLeft'){ e.preventDefault(); if(!prevBtn.disabled) prevBtn.click(); }
      });

      // clique para remover errada da lista exibida
      if (wrongWordsList) wrongWordsList.addEventListener('click', (e) => {
        let target=e.target;
        while(target && !target.classList.contains('chip')) target = target.parentElement;
        if(!target) return;
        const txt=target.textContent.trim();
        const w=txt.replace(/\s*×\s*$/,'').trim();
        if (isReviewMode) {
          const idx = reviewMarkedWrongWords.indexOf(w);
          if(idx >= 0) reviewMarkedWrongWords.splice(idx,1);
        } else {
          const idx = currentMarkedWrongWords.indexOf(w);
          if(idx >= 0) currentMarkedWrongWords.splice(idx,1);
        }
        renderWrongWords();
      });

      // unlock audio
      const isTouchDevice = ('ontouchstart' in window) || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0;
      const unlockAudioBtn = document.getElementById('unlockAudioBtn');
      if(unlockAudioBtn && isTouchDevice){
        unlockAudioBtn.classList.remove('d-none');
        unlockAudioBtn.addEventListener('click', async () => {
          try { if (narratorEnabled) await speakWithPromise('Áudio ativado', { interrupt:true, fallbackMs:700, allowWhenNarratorOff:true }); audioUnlocked=true; if (statusEl) statusEl.textContent='Áudio ativado para este dispositivo.'; } catch(e){ if (statusEl) statusEl.textContent='Não foi possível ativar áudio automaticamente.'; } finally { unlockAudioBtn.classList.add('d-none'); }
        });
      }

      // narrator toggles
      if (narratorToggle) narratorToggle.addEventListener('change', () => {
        narratorEnabled = !!narratorToggle.checked;
        const label = narratorToggle.nextElementSibling;
        if (label) label.textContent = narratorEnabled ? 'Narrador (ativado)' : 'Narrador (desativado)';
        if (statusEl) statusEl.textContent = narratorEnabled ? 'Narrador ativado.' : 'Narrador desativado.';
        if (repeatBtn) { repeatBtn.disabled = !narratorEnabled; repeatBtn.title = narratorEnabled ? 'Repetir palavra (Seta ↑)' : 'Repetir desativado (Narrador desligado)'; }
      });

      if (announceNextToggle) announceNextToggle.addEventListener('change', () => {
        announceNextEnabled = !!announceNextToggle.checked;
        const label = announceNextToggle.nextElementSibling;
        if (label) label.textContent = announceNextEnabled ? 'Falar "Próxima palavra" (ativado)' : 'Falar "Próxima palavra" (desativado)';
        if (statusEl) statusEl.textContent = announceNextEnabled ? 'Anúncio "Próxima palavra" ativado.' : 'Anúncio "Próxima palavra" desativado.';
      });
    })();

    // initial state
    (function initialState(){
      showInactiveClock();
      hideMainTimerProxies();
      hideMainErrorProxies();
      setAutoArmedVisual(autoArmed);
      setErrorToggleVisual(errorMode);
      if (repeatBtn) { repeatBtn.disabled = !narratorEnabled; repeatBtn.title = narratorEnabled ? 'Repetir palavra (Seta ↑)' : 'Repetir desativado (Narrador desligado)'; }
      canShowRedo = false;
      if (totalCountDisplay) totalCountDisplay.textContent = `Carregadas: ${lastLoadedMain || 0}`;
    })();
  </script>
</body>
</html>
